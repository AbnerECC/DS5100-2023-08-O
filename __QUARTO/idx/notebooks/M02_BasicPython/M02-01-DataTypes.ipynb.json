{"title":"NB&colon; Data Types, Operators, and Expressions","markdown":{"headingText":"NB&colon; Data Types, Operators, and Expressions","containsRefs":false,"markdown":"\n\n# Python Data Types\n\nWe declare a number of variables with different value types.\n\nBy 'type' we mean object type. \n\nData types and data structures are both types of object.\n\nData types are created by the way they are written or as keywords ...\n\nHere is a series of literal values (called **literals**):\n\n**Integers**\n\n**Floats (decimals)**\n\n**Strings**\n\nType of quote does not matter, but they must be straight quotes, not \"smart quotes\" that some word processors use.\n\nNote that there is no explicit **character** type as in Java and other languages.\n\n**Boolean**\n\n**Nothing**\n\nIt evaluates to nothing!\n\n**Complex**\n\nFor the physicists and signal processors.\n\n# Getting the type of a value\n\nYou can always find out what kind of type you are working with by calling the `type()` function.\n\n# Assignment\n\nData are assigned to **variables** using the assignment **operator** `=`.\n\nThe variable is always on the **left**, the value assigned to it on the **right**.\n\nThis is not the same as mathemtical equality.\n\nVariables are assigned types **dynamically**. \n\nThis is in contrast to static typing, where you have define variables by asserting what kind of data values they can hold.\n\nPython figures out what type of data is being set to the variable and implicitly stores that info.\n\nNote that `type()` returns the type of the value that a variable holds, not the type \"variable\".\n\n# Deleting variables with `del()`\n\nYou can't delete values!\n\n# Get Object Indenity with `id()`\n\nThis function returns the identity of an object. \n\nThe identity is a number that is guaranteed to be unique and constant for this object during its lifetime (during the program session).\n\nYou can think of it as the address of the object in memory.\n\n# Convert Types with Casting Functions\n\nIt is possible to convert between types (when it makes sense to do so).\n\nSometimes conversions are \"lossy\" -- you lose information in the process\n\n## `int()` \n\n**Float to Int**\n\n**String to Float**\n\n**Converting string decimal to integer will fail:**\n\n## `ord()`\n\n**Converting a character to it's code point**\n\n# Operators\n\nIf variables are **nouns**, and values **meanings**, then operators are **verbs**.\n\nIn effect, they are **elementary functions** that are expressed in sequential syntax.\n\n`a + b` could have been expressed as `add(a, b)`.\n\nBasically, **each data type is associated with a set of operators** that allow you to manipulate the data in way that makes sense for its type. Numeric data types are subject to mathematical operations, booleans to logical ones, and so forth.\n\nThere are also **operations appropriate to structures**. For example, list-like things have membership.\n\nThe relationship between types and operators is a microcosm of the relationship betweed data structures and algorithms. **Data structures imply algorithms and algorithms assume data structures.**\n\nThe w3schools site has [a good summary](https://www.w3schools.com/python/python_operators.asp).\n\nHere are some you may not have seen.\n\n## Arithmetic Operators\n\n### floor division `//`\n\n### modulus `%`\n\nReturns the remainder\n\nodd integers % 2 = 1  \neven integers % 2 = 0\n\nLook at this ... \n\n### exponentiation `**`\n\n## String Operators\n\n### concatenation `+`\n\nThe plus sign is an **ovderloaded** operator in Python.\n\n### repetition `*`\n\n[See them all](https://simpsonswiki.com/wiki/List_of_chalkboard_gags) :-)\n\n## Assignment Operator `=`\n\nWe've used this already, but it too is an operator.\n\n## Comparison Operators\n\nComparisons are questions.\n\nThey return a boolean value. \n\n### equality `==`\n\nCan we compare strings\n\n### inequality `!=`\n\n## Logical Operators\n\nPython uses words where other languages will use other symbols.\n\n### Conjunctions `and`, `or`, `not`\n\nNote the we group comparisons with parentheses.\n\n### Identity `is`\n\nThe `is` keyword is used to test if two variables refer to the same object.\n\nThe test returns `True` if the two objects are the same object.\n\nThe test returns False if they are not the same object, even if the two objects are 100% equal.\n\nUse the `==` operator to test if two variables are equal.\n\n-- from [W3Schools on Identity Operators](https://www.w3schools.com/python/gloss_python_identity_operators.asp)\n\n`is`\n\n`is not`\n\n### Negation `not`\n\n# Unary Operators\n\nPython offers a short-cut for most operators. When updating a variable with an operation to that variable, such as:\n```python\nmy_var = my_var + 1  # Incrementing\n```\n\nYou can do this:\n```python\nmy_var += 1\n```\n\n\nPython supports many operators this way. Here are some:\n```python\na -= a\na \\= a\na \\\\= a\na %= a\na *= a\na **= a\n```\n\n# Expressions\n\nVariables, literal values, and operators are the building blocks of ebxpressions.\n\nFor example, the following combines three operators and four variables:\n\nPython employs **operator precedence** when evaluating expressions:\n\n```\nP – Parentheses\nE – Exponentiation\nM – Multiplication\nD – Division\nA – Addition\nS – Subtraction\n```\n\nYou can use parentheses to group them to force the order of operations you want:\n\nVariables and literal values can be combined:\n\nExpresssion can be very complex.\n\nExpressions evaluate to a value, just as single variables do. \n\nTherefore, they can be put anywhere a value is accepted.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M02-01-DataTypes.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false},"extensions":{"book":{"multiFile":true}}}}}