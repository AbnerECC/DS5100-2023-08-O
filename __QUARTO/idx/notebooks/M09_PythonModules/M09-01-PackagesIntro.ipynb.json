{"title":"NB: Packages, Modules, and Imports","markdown":{"headingText":"NB: Packages, Modules, and Imports","containsRefs":false,"markdown":"\n\n## Modules\n\nIn Python, a **module** is a file containing Python code -- expressions and statements. \n\nThe module name is just the file name without the `.py` suffix. \n\nWhen the file is executed and the program is running, \\\nthe module’s name is available as the value of the global variable `__name__`.\n\nFor instance, let's say we have a file called `fibo.py` with the following code:\n\n```python\n## Fibonacci numbers module\n\ndef fib(n):    # print Fibonacci series up to n\n    a, b = 0, 1\n    while a < n:\n        print(a, end=' ')\n        a, b = b, a+b\n    print()\n\ndef fib2(n):   # return Fibonacci series up to n\n    a, b = 0, 1\n    result = []\n    while a < n:\n        result.append(a)\n        a, b = b, a+b\n    return result\n```\n\nWe can import it into this notebook and get it's filename.\n\nAnd here is how we interact with the file as a module:\n\n## Aside on Namespaces\n\nYou can see that a python **module** acts as a single **namespace**, which is used to organize a collection of values:\n\n-   functions\n-   constants\n-   class definitions\n-   really any old value\n\nA namespace is **a collection of currently defined names** being used by a program.\n\n> You can think of it as something like a Python dictionary in which the keys are the object names\\\nand the values are the objects themselves.\n\nIt's a way of making sure variable and function names do not collide or get confused with each other.\n\nPython has four namespaces:\n\n* **Built-In**: Contains the names of all of Python’s built-in objects. See `dir(__builtins__)`\n\n* **Global**: Contains any names defined at the level of the main program. \n\n> A global namespace is also created for any module that your program imports. See `globals()`.\n\n* **Enclosing**: The namespaces of a function for any functions defined within that function. \n\n* **Local**: Contains any names defined in a function.\n\nNamespaces are related to **scope**. \n\nTo know the context in which a name has meaning, Python searches namespaces from the inside out.\n\n    L -> E -> G -> B\n\n![image.png](../../media/scope.png)\n\nSee `M09-01a-Globals.ipynb` for a demo.\n\nSee [Namespaces and Scope in Python (Real Python)](https://realpython.com/python-namespaces-scope/) for a good primer.\n\n## Packages\n\n**A package is a directory** that may contain other modules.\n\nFor a directory to be a package, it must contain an `__init__.py` file.\n\nThe `__init__.py` can be **totally empty** or it can have some Python code in it. We'll see why you would do that below.\n\nIt it will contain other python files or other package directories, too.\n\nHere is an example directory structure of a package that contains a package:\n\n```bash\n## EXAMPLE 1 \na_package_dir\n    __init__.py\n    module_a.py\n    a_sub_package_dir\n        __init__.py\n        module_b.py\n```\n\nAt a minimum, all you need to do have is this:\n\n```bash\n## EXAMPLE 2\na_package_dir\n    __init__.py\n    module_a.py\n```\nHowever, **ideally**, if you want to have your package **installed**, you'd include other files, too:\n\n```bash\n## EXAMPLE 3\na_package_dir\n    __init__.py\n    module_a.py\ntests\n    ...\nsetup.py # Or pyproject.toml \n```\n\n\n![](19BFA18D-1187-43E1-9E0E-820C782C352C.jpg)\n\n## Packages and Namespaces\n\nPackages structure Python’s **module namespace** by setting up **dotted module names.** \n\n> File system constructs are mapped onto Python name constructs.\n\nFor example, the module name `A.B` designates a submodule named `B` in a package named `A`. \n\nThe use of dotted module names saves the authors of multi-module packages like NumPy or Pillow from having to worry about each other’s module names.\n\n## Importing Packages and Modules\n\nSo, given the above directory and file structure, within a Python file you can:\n\n```\nimport a_package\n````\n\nThis will run any code in `a_package/__init__.py`.\n\nSo, any variable or function names defined in the `__init__.py` will be available like this:\n\n```\na_package.a_name\n```\n\nHowever, no **modules** will be imported unless explicity commanded to. \n\nFor example:\n\n```\na_package.module_a\n```\n\nwill not be imported. \n\nTo get modules, you need to explicitly import them:\n\n```\nimport a_package.module_a\n```\n\nYou will have noticed this in working with well-known libraries (bundles of packages) like Scikit Learn. \n\n## The module search path\n\nHow does Python know where to find modules?\n\nThe interpreter keeps a list of all the places that it looks for modules or packages when you do an import. It is stored in the `sys` module.\n\n```python\nimport sys\nfor p in sys.path:\n    print p\n```\n\nYou can edit that list to add or remove paths to let python find\nmodules on a new place.\n\n```python\nsys.path.append(some_local_dir)\n```\n\nRemember that every module has a `__file__` name that points to the path it lives in. \n\nThis lets you add paths relative to where you are, etc.\n\n```python\nsys.path.append(f\"{__file__}/local_module_directory\")\n```\n\n## More Info\n\nThere is, of course, a lot more to this topic than what's covered here.\n\nWe've covered what you need to know to get started.\n\nSee [the official docs on modules](https://docs.python.org/3/tutorial/modules.html#packages) for more depth.\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M09-01-PackagesIntro.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false},"extensions":{"book":{"multiFile":true}}}}}