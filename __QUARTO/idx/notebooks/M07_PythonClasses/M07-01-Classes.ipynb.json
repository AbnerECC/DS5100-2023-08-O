{"title":"NB&colon; Introducing Classes","markdown":{"headingText":"NB&colon; Introducing Classes","containsRefs":false,"markdown":"\n\n## Introduction\n\nClasses are a way **organizing code** into bundles of variables and functions called **attributes** and **methods**.\n\nEach class **models** some thing &mdash; a thing in the world, a process, a model, or just some convenient way of grouping code.\n\nFor example, a logistic regression model would have attributes like:\n\n- weights\n- an optional intercept term\n- the maximum number of iterations\n\nThese attributes help describe the object; they give the object's **state**.\n\nThe logistic regression model would have **functionality** such as:\n\n- the optimization routine used in training\n- a prediction function\n\nThe behavior, or functionality, is supported by methods, which are functions included in the class.\n\nHere are a couple of others way to think of a class:\n\n- It provides **a template** for creating an object and for working with the object.\n- It constitutes a kind of **definition** of something in the world.\n\n### A First Example \n\nOk, let's look at examples, starting with a very small, simple class.  \nThe class contains:\n\n- a name `Ferrari458`\n- a docstring for a quick description\n- an attribute, which is number of cylinders in the engine\n- a method\n\nYou can learn about the class by printing the docstring:\n\nYou can also get detailed help like this:\n\nNext, we create an object from the class (also called an **instance** of the class).  \n\nIt is called like a function with no parameters.\n\nThe process is called **instantiation**.\n\nWe show the number of cylinders by using the `object.attribute` format:\n\nThen we call its method `.print_origin()` to learn where this sweet machine was built.\n\nAs a convention, methods take `self` as their first argument. Methods can use `self.attribute` to extract their attributes.  \nHere is an example, with method `get_cylinders`.\n\n## The  `.__init__()` method\n\nThere is a special function called `__init__` that will **initialize** the state of objects for you when you create them.\n\nUse it to supply more context-dependent information about your instance.\n\nLet's look at another version of the class with __init__.\n\nBy adding the `__init__` function, we can create objects if we pass the number of cylinders.  \n\nIf we don't pass this parameter, there will be an error.\n\nThis is because we did not define a default value for the color argument in our initialization method.\n\nThis works:\n\nWe can access the initialized attribute using the dot operator, just as if it were declared at the top of the class:\n\nOr we can call the accessor method that we created.\n\nNote that even though we initialized the car object with \"red\", we can always change it:\n\n## The Meaning of `self`\n\nNote the presence of an argument and variable called **`self` in the method definitions**. \n- This stands for the intantiated object itself. \n\nSo, when you create an object like so:\n\n```python\nfoo = Foo()\n```\n- `foo` is represented in the class definition as `self`.\n\nIf you want your method to access the other attributes and methods in an object, **you need to put self as its first argument**.\n- Note that when you use the method with an instance, you don't pass the object name as an argument\n- The object name is passed implicitly by Python, since it knows which object called the methid\n\n\nYou can use any valid name you want for the name of the object itself, but the convention is to use `self`.\n\nNote that `self` is **only used within the methods** of a class, not outside of it. \n- Like functions, they don't know what's outside of them, nor does the containing code know what's inside of them.\n- The `self` variable is the mechanism that allows methods to share data without having to pass and return a bunch of variables.\n\nThink of `self` as a **data structure that stores the program itself**\n- In this sense, it's similar to **recursion**: A class definition contains a reference to itself!\n- But remember, the class definition is not a thing -- it's a template.\n- `self` is just a pronoun that allows an instance to access it's own state.\n\n## Summary\n\nAn **cobject** is a self-contained bundle of **methods and attributes**.\n* Methods are basically functions.\n* Attributes are basically variables.\n\nA **class** definition is a **template** for creating objects.\n* Objects are **class instances**. \n* Classes are **onbject types**.\n\nObjects have **their own scope**, like functions.\n* They are meant to **exchange information** with their environment only through accessing attributes and calling methods\n\nWhen objects are first created, **they often expect to have data passed to them**.\n* This is called **initializing** the object.\n* These data are handled internally by the `.__init__()` method. \n* Data that are passed this way can be **overridden** by accessing the attributes they assigned to.\n\nThe methods of a class begin with `self` as the first argument.\n* This stands for **the instance itself**.\n* **All methods and attributes are avaible** to all other methods in the object **through the `self` object**.\n\nIf a method does not have `self` as its first argument, it cannot access the internal state or methods of the object.\n* The internal state is just the attributes and their current values.\n* These are called **static** methods.\n* Static methods are useful in providing functions to the environment in which their containing object is instantiated.\n\n**There is a lot more to the subject, but this is good enough to get started!**\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M07-01-Classes.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false},"extensions":{"book":{"multiFile":true}}}}}