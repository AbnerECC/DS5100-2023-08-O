{"title":"NB: Introducing Tibbles","markdown":{"headingText":"NB: Introducing Tibbles","containsRefs":false,"markdown":"\n> Based on [Wikham and Grolemund 2017](https://r4ds.had.co.nz/index.html)\n\n## The Tidyverse\n\nTidyverse is a collection of essential R packages for data science.\n\nThe packages included in the Tidyverse are designed to support the pipeline of activities associated with data science, such as filtering, transforming, visualizing, etc.\n\n![](images/paste-EE0D9577.png)\n\nTidyverse was created by **Hadley Wickham** and his team with the aim of providing all these utilities to clean and work with data.\n\nHere's a graphic of the packages associated with the Tidyverse:\n\n![](images/paste-32BD3A67.png)\n\n## Dplyr\n\nDplyr introduces **new set of functions** that make working with data more intuitive.\n\n-   It does this by introducing a set of functions that work together well to produce pipelines of actions.\n\nBut as important, it introduces a **vocabulary** for talking about data.\n\n-   This makes it possible to imagine solutions verbally, and then to implement them in code.\n\nTo use the Tidyverse, we often import everything:\n\n```{r}\nlibrary(tidyverse)\n```\n\n## Piping with `%>%`\n\nJust a quick note about this **odd looking** operator that you will start to see.\n\nOne of the key elements of the Tidyverse is the use of **piping**, or the ability of to pass the return values of one function to another, with without have to nest functions.\n\nFor example, instead of something like this:\n\n```{r}\na <- \"Hello\"\nb <- \"World\"\n\nvar1 <- c(a, b)\nvar2 <- paste(var1)\nprint(var2)\n```\n\nOr this:\n\n```{r}\nprint(paste(c(a,b)))\n```\n\nWe can do:\n\n```{r}\nc(a, b) %>%\n  paste() %>%\n  print()\n```\n\nAlthough the last pattern is longer than the preceding, it is much easier to read and write, especially when we are working with several connected functions.\n\nThis is similar to **method chaining** in Python, but is more pervasive.\n\n-   In Python you can do it with individual objects that return themselves (as it were).\n-   In Tidyverse, you can apply it to **any two methods** so long as it makes sense to pass the output of as the input of another.\n-   Basically, the output of one function becomes the first argument of the following the `%>%`.\n\nIt is similar to the pipe operator `|` in Unix shells.\n\nBy the way, the operator comes with the [**magrittr**](https://magrittr.tidyverse.org/) package, which is a central part of the Tidyverse. It is so central, in fact, that packages in the tidyverse load `%>%` automatically.\n\nIt provides a set of operators which make your code more readable.\n\n# Tibbles\n\nDplyr can work with different rectangular data structures:\n\n-   Plain old Dataframes\n-   Tibbles\n-   Data.tables (see [data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html))\n\nThe foundational data structure of the Tidyverse is the **tibble**.\n\nTibbles are data frames, but they tweak some older behaviors to make your life a little easier.\n\nTo learn more about tibbles, check out the vignette:\n\n```{r}\nvignette(\"tibble\")\n```\n\n## Creating tibbles\n\nIf you need to make a tibble \"by hand\", you can use `tibble()` or `tribble()` (see below).\n\n`tibble()` works by assembling individual vectors, **column-wise** operation:\n\n```{r}\nx <- c(1, 2, 5)\ny <- c(\"a\", \"b\", \"h\")\ntibble(x, y)\n```\n\nYou can also optionally name the inputs, provide data inline with `c()`, and perform computation:\n\n```{r}\ntibble(\n  x1 = x,\n  x2 = c(10, 15, 25),\n  y = sqrt(x1^2 + x2^2)\n)\n```\n\nEvery column in a data frame or tibble must be same length, so you'll get an error if the lengths are different:\n\n```{r eval=FALSE, include=FALSE}\n#| error: true\ntibble(\n  x = c(1, 5),\n  y = c(\"a\", \"b\", \"c\")\n)\n```\n\nAs the error suggests, individual values will be recycled to the same length as everything else:\n\n```{r}\ntibble(\n  x = 1:5,\n  y = \"a\",\n  z = TRUE\n)\n```\n\n## Tribbles\n\nAnother way to create a tibble is with `tribble()`, which short for **transposed tibble**.\n\n`tribble()` is customized for data entry in code: **column headings start with `~`** and **entries are separated by commas**.\n\nThis makes it possible to lay out small amounts of data in an easy to read form:\n\n```{r}\ntribble(\n  ~x, ~y, ~z,\n  \"a\", 2, 3.6,\n  \"b\", 1, 8.5\n)\n```\n\nFinally, if you have a regular `data frame` you can turn it into to a tibble with `as_tibble()`:\n\n```{r}\nas_tibble(mtcars)\n```\n\nThe inverse of `as_tibble()` is `as.data.frame()`; it converts a tibble back into a regular `data.frame`.\n\n## Non-syntactic names\n\nIt's possible for a tibble to have column names that are not valid R variable names, names that are **non-syntactic**.\n\nFor example, the variables might not start with a letter or they might contain unusual characters like a space.\n\nTo refer to these variables, you need to surround them with backticks, `` ` ``:\n\n```{r}\ntb <- tibble(\n  `:)` = \"smile\", \n  ` ` = \"space\",\n  `2000` = \"number\"\n)\ntb\n```\n\nYou'll also need the backticks when working with these variables in other packages, like ggplot2, dplyr, and tidyr.\n\n# Tibbles vs. data.frame\n\nThere are two main differences in the usage of a tibble vs. a classic `data.frame`: **printing** and **subsetting**.\n\n::: callout-tip\nIf these differences cause problems when working with older packages, you can turn a tibble back to a regular data frame with `as.data.frame()`.\n:::\n\n## Printing\n\nThe print method:\n\n-   Only the first 10 rows\n-   All the columns that fit on screen\n\nThis makes it much easier to work with large data.\n\n```{r}\ntibble(\n  a = lubridate::now() + runif(1e3) * 86400,\n  b = lubridate::today() + runif(1e3) * 30,\n  c = 1:1e3,\n  d = runif(1e3),\n  e = sample(letters, 1e3, replace = TRUE)\n) %>% head()\n```\n\nWhere possible, **tibbles also use color** to draw your eye to important differences.\n\nOne of the most important distinctions is between the string `\"NA\"` and the missing value, `NA`:\n\n```{r}\ntibble(x = c(\"NA\", NA))\n```\n\nTibbles are designed to avoid overwhelming your console when you print large data frames.\n\nBut **sometimes you need more output** than the default display.\n\nThere are a few options that can help.\n\nFirst, you can explicitly `print()` the data frame and control the number of rows (`n`) and the `width` of the display. `width = Inf` will display all columns:\n\n```{r}\nlibrary(nycflights13)\nflights %>%\n  print(n = 10, width = Inf)\n```\n\nYou can also **control the default print behavior** by setting options:\n\n-   `options(tibble.print_max = n, tibble.print_min = m)`: if more than `n` rows, print only `m` rows.\n-   Use `options(tibble.print_min = Inf)` to always show all rows.\n-   Use `options(tibble.width = Inf)` to always print all columns, regardless of the width of the screen.\n\nYou can see a complete list of options by looking at the package help with `package?tibble`.\n\n## Using RStudio `View()`\n\nA final option is to use RStudio's built-in data viewer to get a scrollable view of the complete dataset. This is also often useful at the end of a long chain of manipulations.\n\n```{r}\n#| eval: false\nflights %>%\n  View()\n```\n\n## Extracting variables\n\nSo far all the tools you've learned have worked with complete data frames.\n\nIf you want to pull out a single variable, you can use `dplyr::pull()`:\n\n```{r}\ntb <- tibble(\n  id = LETTERS[1:5],\n  x1  = 1:5,\n  y1  = 6:10\n)\n```\n\n```{r}\ntb %>%  \n  pull(x1) # by name\n```\n\n```{r}\ntb %>%  \n  pull(1)  # by position\n```\n\n`pull()` also takes an optional `name` argument that specifies the column to be used as names for a named vector, which you'll learn about in [Chapter -@sec-vectors].\n\n```{r}\ntb %>%  \n  pull(x1, name = id)\n```\n\nYou can also use the base R tools `$` and `[[`. `[[` can extract by name or position; `$` only extracts by name but is a little less typing.\n\nExtract by name:\n\n```{r}\ntb$x1\ntb[[\"x1\"]]\n```\n\nExtract by position:\n\n```{r}\ntb[[1]]\n```\n\nCompared to a `data frame`, **tibbles are more strict**: they never do partial matching, and they will generate a warning if the column you are trying to access does not exist.\n\n```{r}\n# Tibbles complain a lot:\ntb$x\ntb$z\n```\n\n```{r}\n# Data frame use partial matching and don't complain if a column doesn't exist\ndf <- as.data.frame(tb)\ndf$x\ndf$z\n```\n\nFor this reason we sometimes joke that **tibbles are lazy and surly**: they do less and complain more.\n\n## Subsetting\n\nLastly, there are some important differences when using `[`.\n\nWith `data.frame`s, `[` sometimes returns a `data.frame`, and sometimes returns a vector.\n\n-   This is a common source of bugs.\n\nWith tibbles, **`[` always returns another tibble**.\n\n-   This can sometimes cause problems when working with older code.\n-   If you hit one of those functions, just use `as.data.frame()` to turn your tibble back to a `data.frame`.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M11-01-Tibbles.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false},"extensions":{"book":{"multiFile":true}}}}}