{"title":"NB: The `dplyr` package","markdown":{"yaml":{"editor":{"markdown":{"wrap":"sentence"}},"editor_options":{"chunk_output_type":"inline"}},"headingText":"NB: The `dplyr` package","containsRefs":false,"markdown":"\n\n\nThe `dplyr` package was developed by Hadley Wickham of RStudio and is an optimized and distilled version of his `plyr` package.\n\n::: callout-note\n`plyr` is an attempt to organize much of the functionality of the `*apply` family of methods in base R.\nAlthough in many ways superseded the `plyr` and `dplyr`, [they remain useful](https://stackoverflow.com/questions/3505701/grouping-functions-tapply-by-aggregate-and-the-apply-family).\n:::\n\nThe `dplyr` package does not provide any \"new\" functionality to R per se; everything `dplyr` does could already be done with base R.\nBut it *greatly* simplifies existing functionality in R.\n\nOne important contribution of the `dplyr` package is that it provides a **\"grammar\"** (in particular, verbs) for data manipulation and for operating on data frames.\n\nWith this grammar, you can clearly **communicate** what it is that you are doing to a data frame that other people can understand (assuming they also know the grammar).\n\nThis is useful because it provides an abstraction for data manipulation that previously did not exist within R and other programming languages.\n\nAnother useful contribution is that the `dplyr` functions are **very** fast, as many key operations are coded in C++.\n\n## `dplyr` Grammar\n\nSome of the key \"verbs\" provided by the `dplyr` package are:\n\n-   `select`: return a subset of the columns of a data frame, using a flexible notation\n\n-   `filter`: extract a subset of rows from a data frame based on logical conditions\n\n-   `arrange`: reorder rows of a data frame\n\n-   `rename`: rename variables in a data frame\n\n-   `mutate`: add new variables/columns or transform existing variables\n\n-   `summarise` / `summarize`: generate summary statistics of different variables in the data frame, possibly within strata\n\n-   `%>%`: the \"pipe\" operator is used to connect multiple verb actions together into a pipeline\n\n## Common `dplyr` Function Properties\n\nAll of the functions that we will discuss in this Chapter will have a few common characteristics.\nIn particular,\n\n1.  The **first argument** is a **data frame**.\n\n2.  The subsequent arguments describe what to do with the data frame specified in the first argument, and **you can refer to columns in the data frame directly** without using the \\$ operator (just use the column names).\n\n3.  The **return** result of a function is **a new data frame**.\n\n4.  **Data frames must be properly formatted and annotated** for this to all be useful.\n\nIn particular, the data must be [tidy](https://tidyr.tidyverse.org/articles/tidy-data.html) The main principles of tidy data are:\n\n1.  Each variable forms a column.\n\n2.  Each observation forms a row.\n\n3.  Each type of observational unit forms a table.\n\n## Installing the `dplyr` package\n\nThe `dplyr` package can be installed from CRAN or from GitHub using the `devtools` package and the `install_github()` function.\n\nThe GitHub repository will usually contain the latest updates to the package and the development version.\n\nTo install from CRAN, just run\n\n```{r,eval=FALSE}\ninstall.packages(\"dplyr\")\n```\n\nTo install from GitHub you can run\n\n```{r,eval=FALSE}\ninstall_github(\"hadley/dplyr\")\n```\n\nAfter installing the package it is important that you load it into your R session with the `library()` function.\n\n```{r}\nlibrary(dplyr)\n```\n\nYou may get some warnings when the package is loaded because there are functions in the `dplyr` package that have the same name as functions in other packages.\nFor now you can ignore the warnings.\n\n## Getting a dataset\n\nLet's use a dataset containing air pollution and temperature data for the [city of Chicago](http://www.biostat.jhsph.edu/~rpeng/leanpub/rprog/chicago_data.zip) in the U.S.\n\nYou will find the data in the directory for this module.\n\nLoad the data into R using the `readRDS()` function.\n\n```{r}\nchicago <- readRDS(\"chicago.rds\")\n```\n\nYou can see some basic characteristics of the dataset with the `dim()` and `str()` functions.\n\n```{r}\ndim(chicago)\n```\n\n```{r}\nstr(chicago)\n```\n\n```{r}\nhead(chicago)\n```\n\n# Core Methods\n\n## `select()`\n\nWe use the `select()` function to **select columns you want to focus on**.\n\nSuppose we wanted to take the first 3 columns only.\n\nThere are a few ways to do this.\n\nWe could for example use numerical indices.\n\n```{r}\nhead(chicago[names(chicago)[1:3]])\n```\n\nBut we can also use the names directly.\n\n```{r}\nchicago %>%\n  select(city:dptp) %>%\n  head(10)\n```\n\nNote the use of `:` inside the `select()` --- you can use it to specify a range of variable names.\n\nYou can also *omit* variables using the `select()` function by using **the negative sign**.\n\nWith `select()` you can do:\n\n```{r}\nselect(chicago, -(city:dptp)) %>% head(10)\n```\n\nThis indicates that we should include every variable *except* the variables `city` through `dptp`.\n\nThe equivalent code in base R would be\n\n```{r}\ni <- match(\"city\", names(chicago))\nj <- match(\"dptp\", names(chicago))\nhead(chicago[, -(i:j)])\n```\n\nNot super intuitive, right?\n\nThe `select()` function also allows a special syntax that allows you to specify **variable names based on patterns**.\n\nSo, for example, if you wanted to keep every variable that ends with a \"2\", we could do\n\n```{r}\nchicago %>%\n  select(ends_with(\"2\")) %>%\n  head(10)\n```\n\nOr if we wanted to keep every variable that starts with a \"d\", we could do\n\n```{r}\nchicago %>%\n  select(starts_with(\"d\")) %>%\n  head(10)\n```\n\nThis is super useful if you have a table with prefixes, such as `doc_`.\n\nYou can also use more general **regular expressions** if necessary.\n\nSee `?select` for more info.\n\n```{r}\n?select\n```\n\n## Aside: Helper Functions\n\nNote the use the function `ends_with()` inside of the argument space for the function `select()` above.\n\n`ends_with()` is an example of a \"helper function\" --- a function that helps make dplyr functions more effective.\n\nThere are many of these introduced by dplyer.\nHere is a set of helper functions that can be especially useful with `select()` and related functions to specify variable names based on certain patterns or characteristics:\n\n| Helper Function | Description                                                    | Example                                        |\n|-----------------------------|------------------------|-------------------|\n| `starts_with()` | Matches variable names that start with a given prefix          | `select(data, starts_with(\"X\"))`               |\n| `ends_with()`   | Matches variable names that end with a given suffix            | `select(data, ends_with(\"_2019\"))`             |\n| `contains()`    | Matches variable names that contain a given string             | `select(data, contains(\"income\"))`             |\n| `matches()`     | Matches variable names that match a given regular expression   | `select(data, matches(\"^X[1-3]$\"))`            |\n| `num_range()`   | Matches variable names that match a pattern of prefix + number | `select(data, num_range(\"X\", 1:3))`            |\n| `one_of()`      | Matches variable names that are in a given set of names        | `select(data, one_of(c(\"var1\", \"var2\")))`      |\n| `everything()`  | Matches all variable names (used to reorder variables)         | `select(data, starts_with(\"X\"), everything())` |\n\n## `filter()`\n\nThe `filter()` function extracts **subsets of rows** from a data frame.\n\n::: callout-note\n`select()` is a **column-wise** operation, `filter()` is **row-wise**.\n:::\n\nThis function is similar to the existing `subset()` function in R but is quite a bit faster.\n\nSuppose we wanted to extract the rows of the `chicago` data frame where **the levels of PM2.5 are greater than 30** (which is a reasonably high level), we could do\n\n```{r}\nchicago %>%\n  filter(pm25tmean2 > 30) %>%\n  head(10)\n```\n\nYou can see that there are now only 194 rows in the data frame and the distribution of the `pm25tmean2` values is.\n\n```{r}\nsummary(chicago$pm25tmean2)\n```\n\nWe can place an arbitrarily complex logical sequence inside of `filter()`, so we could for example extract the rows where PM2.5 is greater than 30 *and* temperature is greater than 80 degrees Fahrenheit.\n\n```{r}\nchicago %>%\n  filter(pm25tmean2 > 30 & tmpd > 80) %>%\n  select(date, tmpd, pm25tmean2)\n```\n\n```{r}\n?filter\n```\n\nHere's a table of helper functions specifically associated with `filter()`:\n\n| **Helper Function**  | **Description**                                                                                | **Example**                                          |\n|------------------|----------------------------|--------------------------|\n| `between()`          | Check if a value lies between two other values.                                                | `filter(data, between(age, 18, 30))`                 |\n| `near()`             | Check for near equality (useful for floating-point numbers).                                   | `filter(data, near(price, 19.99, tolerance = 0.01))` |\n| `isin()` (or `%in%`) | Check if a value is in a set of values.                                                        | `filter(data, region %in% c(\"East\", \"West\"))`        |\n| `all_of()`           | Check for all of the variables, even if some don't exist. Useful with character vectors.       | `filter(data, all_of(variables))`                    |\n| `any_of()`           | Check for any of the variables. Useful with character vectors.                                 | `filter(data, any_of(variables))`                    |\n| `cur_group_id()`     | Identify the current group inside `group_by()`. Useful for more complex filtering with groups. | `filter(data, cur_group_id() == 1)`                  |\n\n## `arrange()`\n\nUse `arrange()` to **reorder rows** of a data frame according to one or more of the **columns**.\n\n> This normally called **sorting**, but this word is already used in R.\n\nReordering rows of a data frame (while preserving corresponding order of other columns) is normally a pain to do in R.\n\nThe `arrange()` function simplifies the process quite a bit.\n\nHere we order the rows of the data frame by date in ascending order:\n\n```{r}\nchicago_by_date <- chicago %>%\n  arrange(date)\n\nhead(chicago_by_date)\n```\n\nWe can now check the first few rows\n\n```{r}\nchicago_by_date %>%\n  select(date, pm25tmean2) %>%\n  head(3)\n```\n\nand the last few rows.\n\n```{r}\nchicago_by_date %>%\n  select(date, pm25tmean2) %>%\n  tail(3)\n```\n\nColumns can be arranged in descending order too by using the special `desc()` operator.\n\n```{r}\nchicago %>%\n  arrange(desc(date)) %>%\n  head()\n```\n\nHere's a table of helper functions specifically associated with `arrange()`:\n\n| **Helper Function** | **Description**                                                                     | **Example**                               |\n|------------------|----------------------------|--------------------------|\n| `desc()`            | Order by descending instead of default ascending.                                   | `arrange(data, desc(salary))`             |\n| `across()`          | Apply to multiple columns, especially with `c_across()` in `dplyr` 1.0.0 and later. | `arrange(data, across(starts_with(\"X\")))` |\n| `row_number()`      | Create an index based on the order of rows.                                         | `mutate(data, idx = row_number())`        |\n\nNote that while `row_number()` can be used in conjunction with `arrange()`, it's often seen in `mutate()` for creating an index column based on ordering.\n\nThe `across()` function, introduced in `dplyr` version 1.0.0, provides a more concise syntax for working with multiple columns.\nIt can be especially useful in `arrange()` when you're trying to order rows based on a selection of columns that match a certain criterion.\n\nNote that most of the magic with `arrange()` happens through the way you structure its arguments and not necessarily through a large set of helper functions.\n\n## `rename()`\n\nRenaming a variable in a data frame in R is surprisingly hard to do!\n\nThe `rename()` function is designed to make this process easier.\n\nHere we the names of the first five variables in the `chicago` data frame.\n\n```{r}\nhead(chicago[, 1:5], 3)\n```\n\nThe `dptp` column is supposed to represent the dew point temperature and the `pm25tmean2` column provides the PM2.5 data.\n\nHowever, these names are awkward and should be renamed to something more sensible.\n\n```{r}\nchicago <- chicago %>%\n  rename(dewpoint = dptp, pm25 = pm25tmean2)\n  \nchicago %>%  \n  head(3)\n```\n\nThe syntax inside the `rename()` function is to have the new name on the left-hand side of the `=` sign and the old name on the right-hand side.\n\nI leave it as an exercise for the reader to figure how you do this in base R without `dplyr`.\n\nHere's a table of helper functions that can be used with `rename()`:\n\n| **Helper Function** | **Description**                                      | **Example**                                                                                                                     |\n|----------------|--------------------------|------------------------------|\n| `starts_with()`     | Match columns that start with a given prefix.        | `rename(data, start_X = starts_with(\"X\"))` (Note: This example would rename the first column that starts with \"X\" to \"start_X\") |\n| `ends_with()`       | Match columns that end with a given suffix.          | `rename(data, end_year = ends_with(\"_2021\"))`                                                                                   |\n| `contains()`        | Match columns that contain a given string.           | `rename(data, has_rate = contains(\"rate\"))`                                                                                     |\n| `matches()`         | Match columns that match a given regular expression. | `rename(data, match_num = matches(\"^X[1-3]$\"))`                                                                                 |\n| `everything()`      | Match all columns.                                   | Rarely used with `rename()`, but possible.                                                                                      |\n\nIt's worth noting that these helper functions will typically target the first column that meets the specified criterion.\nIf there are multiple columns that match the criterion (e.g., multiple columns that start with \"X\"), you'll need to use these helpers with more precision or utilize other techniques.\n\nAlso, remember to always refer to the official `dplyr` documentation as the package continues to evolve and new functionalities might be added over time.\n\n## `mutate()`\n\nThe `mutate()` function creates new columns based on computations usually involving the other columns.\n\nFor example, with air pollution data, **we often want to *de-trend* the data by subtracting the mean from the data**.\n\nThat way we can look at whether a given day's air pollution level is higher than or less than average (as opposed to looking at its absolute level).\n\nHere we create a `pm25detrend` variable that subtracts the mean from the `pm25` variable.\n\n```{r}\nchicago <- chicago %>%\n  mutate(pm25detrend = pm25 - mean(pm25, na.rm = TRUE))\nchicago %>%\n  head()\n```\n\nThere is also the related `transmute()` function, which does the same thing as `mutate()` but then ***drops all non-transformed variables***.\n\nHere we detrend the PM10 and ozone (O3) variables.\n\n```{r}\nchicago %>%\n  transmute(pm10detrend = pm10tmean2 - mean(pm10tmean2, na.rm = TRUE), \n            o3detrend = o3tmean2 - mean(o3tmean2, na.rm = TRUE))\n```\n\nNote that there are only two columns in the transmuted data frame.\n\nHere's a table of helper functions specifically associated with `mutate()`:\n\n| **Helper Function**                             | **Description**                                                | **Example**                                                                          |\n|----------------|-------------------------|-------------------------------|\n| `if_else()`                                     | A vectorized conditional operation (if-else).                  | `mutate(data, status = if_else(age < 18, \"minor\", \"adult\"))`                         |\n| `case_when()`                                   | Generalized multiple conditions for transformations.           | `mutate(data, category = case_when(score > 90 ~ \"A\", score > 80 ~ \"B\", TRUE ~ \"C\"))` |\n| `lead()`                                        | Access the subsequent value in the column.                     | `mutate(data, next_value = lead(column_name))`                                       |\n| `lag()`                                         | Access the preceding value in the column.                      | `mutate(data, previous_value = lag(column_name))`                                    |\n| `row_number()`                                  | Generate row numbers, often used with `arrange()`.             | `mutate(data, rank = row_number())`                                                  |\n| `rank()`, `min_rank()`, `dense_rank()`          | Different types of ranking functions.                          | `mutate(data, rank = rank(score))`                                                   |\n| `cumsum()`, `cumprod()`, `cummin()`, `cummax()` | Cumulative functions.                                          | `mutate(data, cumulative_total = cumsum(total))`                                     |\n| `coalesce()`                                    | Return the first non-missing value among its arguments.        | `mutate(data, combined = coalesce(col1, col2))`                                      |\n| `na_if()`                                       | Replace a specified value with NA.                             | `mutate(data, updated_col = na_if(column_name, \"replace_me\"))`                       |\n| `replace_na()`                                  | Replace NA values with a specified value.                      | `mutate(data, updated_col = replace_na(column_name, \"new_value\"))`                   |\n| `recode()`                                      | Recode or replace values in a column.                          | `mutate(data, recoded_col = recode(column_name, old=\"new\", ...))`                    |\n| `across()`                                      | Apply a function across multiple columns (from `dplyr` 1.0.0). | `mutate(data, across(c(col1, col2), function_name))`                                 |\n\n## `group_by()`\n\nThe `group_by()` function is used to generate **summary or aggregate statistics** from a data frame.\n\nFor example, in this air pollution dataset, you might want to know the **average annual level of PM2.5**.\n\nSo **the stratum is the year**, which we can derive from the `date` variable.\n\n**In conjunction with the `group_by()` function we often use the `summarize()` function.**\n\nThe general operation here is a combination of **splitting** a table into separate pieces defined by a variable or group of variables (`group_by()`), and then **applying** a summary function across those subsets (`summarize()`), then **combining** back into another table.\n\n> This pattern is called **split, apply, and combine**.\n> It is a fundamental pattern in data processing.\n\nFirst, we can create a `year` variable using `as.POSIXlt()`.\n\n```{r}\nchicago <- chicago %>%\n  mutate(year = as.POSIXlt(date)$year + 1900)\nhead(chicago)\n```\n\nNow we can compute summary statistics for each year in the data frame with the `summarize()` function.\n\n```{r}\nyears <- chicago %>%\n  group_by(year) %>%\n  summarize(pm25 = mean(pm25, na.rm = TRUE), \n          o3 = max(o3tmean2, na.rm = TRUE), \n          no2 = median(no2tmean2, na.rm = TRUE), .groups = \"drop\")\nhead(years)\n```\n\nNote in the process, we implicitly created separate data frame that splits the original data frame by year, which is then passed to `summarize()`.\n\n`summarize()` then returns a data frame with columns for `year` and the annual averages of `pm25`, `o3`, and `no2`.\n\nIn a slightly more complicated example, we might want to know what are the average levels of ozone (`o3`) and nitrogen dioxide (`no2`) within quantiles of `pm25`.\n\nA slicker way to do this would be through a regression model, but we can actually do this quickly with `group_by()` and `summarize()`.\n\nFirst, we can create a categorical variable of `pm25` divided into quantiles.\n\n```{r}\nqq <- quantile(chicago$pm25, seq(0, 1, 0.2), na.rm = TRUE)\nqq\n```\n\nThen can group the data frame by the `pm25.quint` variable.\nand compute the mean of `o3` and `no2` within quantiles of `pm25`.\n\n```{r}\nchicago %>%\n  mutate(pm25.quint = cut(pm25, qq)) %>%\n  group_by(pm25.quint) %>%\n  summarize(o3 = mean(o3tmean2, na.rm = TRUE), \n          no2 = mean(no2tmean2, na.rm = TRUE),\n          .groups = \"drop\")\n```\n\nFrom the table, it seems there isn't a strong relationship between `pm25` and `o3`, but there appears to be a positive correlation between `pm25` and `no2`.\n\nMore sophisticated statistical modeling can help to provide precise answers to these questions, but a simple application of `dplyr` functions can often get you most of the way there.\n\nHere is another example:\n\n```{r}\nchicago %>%  \n  mutate(month = as.POSIXlt(date)$mon + 1) %>% \n  group_by(month) %>%                              # SPLIT\n  summarize(pm25 = mean(pm25, na.rm = TRUE),       # APPLY \n    o3 = max(o3tmean2, na.rm = TRUE), \n    no2 = median(no2tmean2, na.rm = TRUE),\n    .groups = \"drop\")\n                                                   # COMBINE (in the result)\n```\n\nHere's a table of helper functions specifically associated with `group_by()`:\n\n| **Helper Function**                             | **Description**                                                                                                 | **Example**                                                              |\n|----------------|--------------------------|------------------------------|\n| `add_tally()`                                   | Adds a column with the count of each group (equivalent to adding a count with `mutate()` after a `group_by()`). | `group_by(data, group_var) %>% add_tally()`                              |\n| `group_size()`                                  | Returns the size of each group.                                                                                 | `group_by(data, group_var) %>% summarise(size = group_size())`           |\n| `ntile()`                                       | Creates rank percentiles within groups.                                                                         | `group_by(data, group_var) %>% mutate(perc = ntile(score, 4))`           |\n| `cur_group_id()`                                | Gives an integer identifier for the current group.                                                              | `group_by(data, group_var) %>% filter(cur_group_id() == 1)`              |\n| `cur_group_rows()`                              | Provides row indices for the current group.                                                                     | Used internally, but can be useful for advanced operations.              |\n| `group_map()`, `group_modify()`, `group_walk()` | Functions to iterate over groups, modify them or walk them with side effects.                                   | `group_map(data, ~ head(.x, 2))` shows the first two rows of each group. |\n\nIt's worth noting that `group_by()` often works in tandem with other verbs, so the real power comes from the combined operations.\nFor instance, after grouping data, one often uses `summarise()` to calculate summary statistics for each group.\nThe combination of these functions and their associated helpers allow for a wide range of group-wise data manipulation tasks.\n\n# Summary\n\nThe `dplyr` package provides a concise set of operations for managing data frames and tibbles.\n\nIt allows us to perform a number of complex operations in just a few lines of code.\n\nIn particular, we can often conduct the beginnings of an exploratory analysis with the powerful combination of `group_by()` and `summarize()`.\n\nOnce you learn the `dplyr` grammar there are a few additional benefits --- `dplyr` can work with other data frame \"back ends\" such as SQL databases.\nThere is an SQL interface for relational databases via the DBI package --- `dplyr` can be integrated with the `data.table` package for large fast tables\n\nThe `dplyr` package is handy way to both simplify and speed up your data frame management code.\nIt's rare that you get such a combination at the same time!\n\n------------------------------------------------------------------------\n\n> Based on [Peng 2022](https://bookdown.org/rdpeng/rprogdatascience/)\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M11-02-Dplyr.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false,"editor":{"markdown":{"wrap":"sentence"}},"editor_options":{"chunk_output_type":"inline"}},"extensions":{"book":{"multiFile":true}}}}}