{"title":"NB: Recursion","markdown":{"headingText":"NB: Recursion","containsRefs":false,"markdown":"\n\n**Concepts**\n- recursion\n- recursive function\n- stack\n- stack overflow\n\n## Introduction\n\nA recursive function is **a function that calls itself**.\n\nThis is weird, since it does not seem possible. How can a definition refer to itself?\n\nIn philosophy, this is expressed in the Barber's Paradox:\n\n> The barber is the one who shaves all those, and those only, who do not shave themselves. Does the barber shave himself?\n\nFormally, it is a type of [self-reference](https://en.wikipedia.org/wiki/Self-reference), like `This sentence is false.`\n\n**A Cute Definition**\n\n**recursion** - the art of defining something (at least partly) in terms of itself, which is a naughty no-no in dictionaries but often works out okay in computer programs if you’re careful not to recurse forever (which is like an infinite loop with more spectacular failure modes).\n\nSource: _PerlDoc_\n\n### A Formal Definition\n\nIn mathematics and computer science, a class of objects or methods exhibits *recursive behavior* when it can be defined by two properties:\n\nA **simple base** case (or cases): a terminating scenario that does not use recursion to produce an answer. \n\nA **recursive step**: a set of rules that reduces all successive cases toward the base case.\n\n### As Seen in Nature\n\nRecursion occurs naturally when a process applies a rule to itself successively. \n\nWe see this in fractals.\n\n### Infinite Loops and Stack Overflows\n\nEvery recursive function must have a base condition that stops the recursion or else the function calls itself infinitely.\n\nThe Python interpreter limits the depths of recursion to help avoid infinite recursions, resulting in stack overflows.\n\nThe **call stack** is where information is stored relating to the active subroutines in a program.\n\nThe call stack has a limited amount of available memory. When excessive memory consumption occurs on the call stack,\nit results in a **stack overflow error**.\n\n### A Note of Caution\n\nSo, Recursion is cool, but is expensive and complicated.\n\nRecursive functions can usually be implemented by traditional loops.\n\n## Example: Computing Factorials\n\n[Source](https://www.programiz.com/python-programming/recursion)\n\nThe factorial of a number $n$ is the product of all the integers from $1$ to $n$. \n\nFor example, the factorial of $5$ (denoted as $5!$) is $1\\times2\\times3\\times4\\times5 = 120$.\n\nLet's implement this in code using a recursive function.\n\n### Recursive Function\n\n### As a while loop\n\n### As a for loop\n\n### Compare functions as $n$ increases\n\n#### Increase n to 50\n\n#### Increase n to 500\n\n#### Increase n to 5000\n\n## Example: The Fibonacci sequence\n\nFib(0) = 0 (base case 1)\n\nFib(1) = 1 (base case 2)\n\nFor all integers n > 1, Fib(n) = Fib(n − 1) + Fib(n − 2)\n\n### As a for loop\n\n## Aside: A General Sequence Function\n\nRecursive functions are often used to produce mathematical sequences, but since they have limits on depth, they are of limited use for this purpose.\n\nHere is a function that can combine many sequences using two sequence parameters:\n* The initial state of the sequence, represented as the list `seq`.\n  * For example, in the Fibonacci sequence, seq is `[1, 1, 2]`\n* The function to apply to the sequence at each iteration, represneted as a `lambda` function with the arguments `x` and `i` for the the sequence list `seq` and the iteration number respectively.\n  * For example, in the Fibonacci sequence the kernel function is `lambda x, i: x[i-1] + x[i-2]`\n\n**The series of positive integers**\n\n**The series of even numbers**\n\n**The series of odd numbers**\n\n**The series of Fibonacci numbers**\n\n**The series of Squares**\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M04-04-RecursiveFunctions.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false},"extensions":{"book":{"multiFile":true}}}}}