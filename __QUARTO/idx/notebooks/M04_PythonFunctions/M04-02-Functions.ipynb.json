{"title":"NB: Introduction to Functions","markdown":{"headingText":"NB: Introduction to Functions","containsRefs":false,"markdown":"\n\n**Objectives**\n- Explain the benefits of functions\n- Illustrate how to use built-in functions\n- Illustrate how to create and use your own (user-defined) functions\n- Demonstrate the scope and lifetime of a variable\n- Illustrate global and local nature of variables through functions\n- Demonstrate function parameter use\n- Provide recommendations on how to create and document functions\n- Show how to print and write docstrings\n\n**Concepts**\n- functions\n- built-in functions\n- user-defined functions\n- variable scope\n- global versus local variables\n- default arguments\n- *args\n- function call\n- docstring\n\n## Introduction\n\nA function is piece of source code, separate fom the larger program, that performs a specific task. \n\nThis section of code is given a name and can be called from the main program. It is called by using its given name.\n\nFunctions are the **verbs** of a programming language. They signify action, and take subjects and objects (as it were).\n\nFunctions take **input** and produce **output**. \n\n- Function inputs are called both **parameters** and **arguments**.\n- Outputs are called **return** values\n\nFunctions are always written with parentheses at the end of their names, e.g.\n\n`len(some_list)`\n\nInternally, they contain a block of code to do their work.  \n\nOften the producte a **transformation** ... from simple to complex.\n\nWhen you use a function, we say you **call** a function. Programmers speak of \"function calls\" and \"callbacks\".\n\n## Benefits\n\nReduce complex tasks into simpler tasks.\n\nEliminate duplicate code -- no need to re-write, reuse function as needed.\n\nCode reuse. Once function is written, you can reuse it in any other program.\n\nDistribute tasks to multiple programmers. For example, each function can be written by someone.\n\nHide implementation details, i.e. abstraction. \n\nIncrease code readability.\n\nImprove debugging by improving traceability. Things are easier to follow; you can jump from function to function.\n\n## Built-in Functions\n\nPython provides many **built-in** functions. See [Python built-in functions](https://docs.python.org/3/library/functions.html).\n\nWe've looked at many of these already.\n\nThese are functions that are available to use any time your are running Python.\n\nTo take one simple example, this is a built-in function: `bool()`. \n\nTakes an argument $x$ and returns a boolean value, i.e. `True` or `False`.  \n\n## Imported Functions\n\nPython is meant to be a highly modular language. \\\nIt is not designed to have a lot of special purpose functions built into it. \\\nThese keeps it light and highly customizable.\n\nMany functions (and other stuff) can be imported into a program to add to the functions that you can call in a script.\n\nThere are also many **packages** to bring in additional functions.\n\nPackages and Libraries\n\n## User-Defined Functions\n\nPython makes it easy for you to write your own functions. These are called **user-defined** functions.\n\nLet's write a function to compare the list against a threshold.\n\n**Let's break down the components**\n\nThe function definition starts with `def`, followed by name, one or more arguments in parenthesis, and then a colon.\n\nNext comes a **docstring** to provide information to users about how and why to use the function.\n\nThe function **body** follows.\n\n:astly is a `return` statement\n\nThe **function call** allows for the function to be used. \\\nIt consists of function name and required arguments:\n\n`vals_greater_than_or_equal_to_threshold(arg1, arg2)` where `arg1`, `arg2` are arbitrary names.\n\n### About the docstring\n\nA **docstring** m occurs as first statement in module, function, class, or method definition\n\nInternally, it is saved in `__doc__` attribute of the function object.\n\nIt needs to be indented. \n\nIt can be a single line or a multi-line string.\n\n### Let's test our function\n\nThe function body used a `list comprehension` for the compare:\n\n`[val >= thresh for val in vals]` \n\nThis gives correct results and does exactly what we want.  \n\n### Users can print the docstring\n\nprint the help\n\n**Let's test our function**\n\nThe function body used a `list comprehension` for the comparison:\n\n`[val >= thresh for val in vals]` \n\nThis gives correct results and does exactly what we want.  \n\nPrint the docstring\n\nPrint the help\n\nUse the `?` prefix ...\n\n## Passing Parameters\n\nFunctions need to be called with correct number of parameters.\n\nThis function requires two params, but the function call includes only one param.\n\n### Parameter Order\n\nWhen calling a function, **parameter order matters**.\n\nGenerally it's best to keep parameters in order.  \n\nYou can swap the order by putting the parameter names in the function call.\n\n### Weirdness Alert\n\nNote that the same name can be used for the parameter names and the variables passed to them. \n\nThe names themselves have nothng to do with each other! \n\nIn other words, just because a function names an argument `foo`, \\\nthe variables passed to it don't have to name `foo` or anything like it. \\\nThey can even be named the same thing -- it does not matter.\n\n## Unpacking List-likes with `*args`\n\nThe `*` prefix operator can be passed to avoid specifying the arguments individually.\n\nWe can pass a tuple of values to the function ...\n\nYou can also pass a list to the function. \n\nIf you want the elements unpacked, put `*` before the list.\n\nThis approach allows your function to accept an arbitrary number of arguments.\n\n**The reverse is true, too.**\n\nYou can use the `*` prefix to pass list-like objects to a function that specifies its arguments.\n\nBut, the passed object must be the right length.\n\n## Default Arguments\n\nUse default arguments to set the value of arguments when left unspecified.\n\nThe function call didn't specify `printing`, so it defaulted to True.\n\n**NOTE:** Default arguments must follow non-default arguments. This causes trouble:\n\n## Returning Values\n\nFunctions are not required to have return statement.\n\nIf there is no return statement, a function returns `None`.  \n\nFunctions can return no value (`None`), one value, or many.  \n\nMany values are returned as a tuple.\n\nAny Python object can be returned.  \n\n**If you don't need an output, use the dummy variable `_`**\n\n**Note:** It's generally a good idea to include return statements, even if not returning a value.  \n\nThis shows that you did not forget to consider the return value.\n\nYou can use `return` or `return None`.\n\n**Functions can contain multiple return statements**.\n\nThese may be used under different logical conditions.\n\nFor non-negative values, the first `return` is reached.  \nFor negative values, the second `return` is reached.\n\n## Function Design\n\nA function is not just a bag of code!\n\nSome good practices for creating and using functions:\n\n- design a function to do one thing\n\nMake them as simple as possible, which makes them: \n\n- more comprehensible\n- easier to maintain\n- reusable\n\nThis helps avoid situations where a team has 20 variations of similar functions.\n\nGive your function a good name. \n\n- It should reflect the action it performs. \n- Be consistent in your naming conventions.\n- A name like `compute_variances_sort_save_print` suggests the function is overworked!\n\nIf the function `compute_variances` also produces plots and updates variables, it will cause confusion.  \n\nAlways give your function a docstring\n- Particularly important since indicating data types is not required.  \n- As a side note, you can include this information by using **type annotation**.\n\nFinally, at some point you may be interested to learn some of the formatting languages that have been developed to write docstrings. See [Lutz 2019](https://learning.oreilly.com/library/view/learning-python-5th/9781449355722/ch15.html) and this web page about [Documenting Python Code](https://realpython.com/documenting-python-code/) for more info.\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M04-02-Functions.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false},"extensions":{"book":{"multiFile":true}}}}}