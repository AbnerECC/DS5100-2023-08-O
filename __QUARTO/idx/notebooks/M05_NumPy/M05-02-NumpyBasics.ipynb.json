{"title":"NB: NumPy First Steps","markdown":{"headingText":"NB: NumPy First Steps","containsRefs":false,"markdown":"\n\n\n\n## NumPy\n\n<img src=\"../../media/numpy-logo.png\" style=\"float:right;\"/>\n\n\n**A new data structure**\n\nEssentially, NumPy introduces a new data structure to Python &mdash; the **n-dimensional array**. \n\nAlong with it, it introduces a collection of **functions and methods** that take advantage of this data structure.\n\nThe data structure is designed to support the use of **numerical methods**: algorithmic approximations to the problems of mathematical analysis.\n\n**New Functions**\n\nIt also provides a new way of applying functions to data made possible by the data structure -- **vectorized functions**. \n\nVectorized functions **replace the use of loops** and comprehensions to apply a function to a set of data. \n\nIn addition, given the data structure, it provides a library of **linear algebra** functions. \n\n**New Data Types**\n\nNumPy also introduces a bunch of new **data types**.\n\n**Python for Science**\n\nNumPy stands for \"**Numerical Python**\".\n\nBecause [numerical methods](https://www.britannica.com/science/numerical-analysis) are so important to so many sciences, NumPy is the basis of what is called **the scientific \"stack\"** in Python, which consists of SciPy, Matplotlib, SciKitLearn, and Pandas. \n\n\n\nAll of these assume that you have some knowledge of NumPy.\n\nLet's take a look at it.\n\n## Importing the Library\n\nNumPy is by widespread convention aliased as `np`.\n\n## The ndarray\n\nThe ndarray is a multidimensional array object.\n\nLet's explore it some. \n\nFirst, let's generate some fake data using NumPy's built-a random number generator.\n\nNote that `np.random.randn()` samples from the \"standard normal\" distribution.\n\n## About Dimensions\n\nThe term \"dimension\" is ambiguous.\n* Sometimes refers to the dimensions of things in the world, such as space and time.\n* Sometimes refers to the dimensions of a data structure, independent of what it represents in the world.\n\nNumPy dimensions are the latter, although they can be used to represent the former, as physicists do.\n\nThe dimensions of data structures are sometimes called **axes**.\n\nConsider this: Three-dimensional space can be represented as three columns in a two-dimensional table OR as three axes in a data cube. \n\n## Creating ndarrays\n\nFrom a list:\n\nFrom a list of lists:\n\nInitializing with $0$s using a convenience function:\n\nUsing `.arange()` (instead of `range()`)\n\n## Data Types for ndarrays\n\nUnlike any of the previous data structures we have seen in Python, \n**ndarrays must have a single data type** associated with them.\n\nHere we initialize a series of arrays as different data types (aka `dtypes`).\n\nNote that dtypes are defined by some **constants attached to the NumPy object**.\n\nWe can also refer to them as strings in some contexts. \n\nIn other words, in the context of the dtype argument, `'float64'` can substitute for `np.float64`.\n\nInteger arrays default to `int64`:\n\nSo you may want in use a more capacious type:\n\nArrays can be cast:\n\nFrom floats to ints:\n\nFrom strings to floats:\n\nNote that NumPy converts data types to make the array uniform:\n\nRanges default to integers:\n\nWe can use the dtype on one array to cast another:\n\nAnd here is an empty array of unsigned integers:\n\n**NumPy Data Types**\n\n```\ni - integer\nb - boolean\nu - unsigned integer\nf - float\nc - complex float\nm - timedelta\nM - datetime\nO - object\nS - string\nU - unicode string\nV - fixed chunk of memory for other type ( void )\n```\n\n**Data Type Hierarchy**\n\nNumPy introduces 24 new fundamental Python types to describe different types of scalars.\n\nThese derive from the C programming language with which NumPy is built.\n\n![](../../media/dtype-hierarchy.png)\n\nSee the [NumPy docs](https://numpy.org/doc/1.25/reference/arrays.scalars.html).\n\n## Element-wise Arithmetic\n\nNumPy arrays can be transformed with with arithmetic operations.\n\nThese are all **element-wise operations**.\n\nLet's start with a 2D array.\n\nNow let's compare two arrays.\n\nBoolean arrays will prove to be very useful ...\n\n## Indexing and Slicing\n\n**Example 1**\n\n&rarr; _Editor's Note, this jumps ahead to multi-dimensional indexing._\n\nWhy is this different?\n\nBecause it operations in sequence, not simultaneously.\n\n**Example 2**\n\nSlices can be used to set values as well.\n\n## Views and Copies\n\nNotice that if we assign a scalar to a slice, all of the elements of the slice get that value. \n\nThis is called **broadcasting**. We'll look at this more later.\n\nAlso, notice that changes to slices are changes to the arrays they are slices of. \n\nThey are **views**, not copies. **This is crucial.**\n\nSee what happens when we change a view:\n\nNumPy defaults to views rather than copies because copies are **expensive** and NumPy is designed with large data use cases in mind.\n\nIf you want a copy of a slice of an ndarray instead of a view, use `.copy()`.\n\nHere's an example:\n\nNote how the original array is unchanged:\n\n## Higher Dimensional Arrays\n\n NumPy can create arrays in N dimensions.\n \n Here is a 2D array initialized from a list of lists.\n\nIndexing into a dimension produces lower-order arrays.\n\n**Simplified notation:** NumPy offers an elegant way to specify multidimensional indices and slices.\n\nInstead of `x[a][b][c]` you can write `x[a,b,c]`.\n\nA nice visual of a 2D array\n\n<img src=\"https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781449323592/files/httpatomoreillycomsourceoreillyimages2172112.png\" height=\"50%\" width=\"50%\"/>\n\n**Two-Demensional Array Slicing**\n\n<img src=\"https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781449323592/files/httpatomoreillycomsourceoreillyimages2172114.png\" height=\"50%\" width=\"50%\"/>\n\n**3D arrays**\n\nI find NumPy's way of show the data a bit difficult to parse visually.\n\n**Here is a way to visualize 3 and higher dimensional data:**\n\n```python\n[ # AXIS 0                     AXIS 1 CONTAINS 2 ELEMENTS (arrays)\n    [ # AXIS 1                 EACH MEMBER OF AXIS 2 CONTAINS 2 ELEMENTS (arrays)\n        [1, 2, 3], # AXIS 2    EACH MEMBER OF AXIS 3 CONTAINS 3 ELEMENTS (integers)\n        [4, 5, 6]  # AXIS 2\n    ],  \n    [ # AXIS 1\n        [7, 8, 9], \n        [10, 11, 12]\n    ]\n]\n```\nEach axis is a level in the nested hierarchy, i.e. a tree or DAG (directed-acyclic graph).\n\n* Each axis is a container.\n* There is only one top container.\n* Only the bottom containers have data.\n\n**Omit lower indices**\n\nIn multidimensional arrays, if you omit later indices, the returned object will be a **lower-dimensional ndarray** consisting of all the data contained by the higher indexed dimension. \n\nSo in the 2 × 2 × 3 array `arr3d`:\n\nSaving data before modifying an array.\n\nYou can work with these lower dimensional arrays using views and copies.\n\nPutting the data back.\n\nSimilarly, `arr3d[1, 0]` gives you all of the values whose indices start with (1, 0), forming a 1-dimensional array:\n\n## Indexing 2D arrays with slices\n\nWe demonstrate indexing in 2D arrays.\n\n## Boolean Indexing\n\nThis a crucial topic -- it applies to Pandas and R. \n\nYou can pass a boolean representation of an array to the array indexer (i.e. the `[]` suffix) \nand it will return only those cells that are `True`.\n\nLet's assume that we have two related arrays:\n* `names` which holds the names associated with the data in each row, or **observations**, of a table.\n* `data` which holds the data associated with each **feature** of a table.\n\nThere are $7$ observations and $4$ features.\n\nA comparison operation for an array returns an array of booleans.\n\nLet's see which names are `'Bob'`:\n\nNow, this boolean expression can be passed to an array indexer to the data:\n\nAlong the second axis, we can use a slice to select data.\n\nIf you know SQL, this is like the query:\n\n```sql\nSELECT col3, col4 FROM data WHERE name = 'Bob'\n```\n\n## Negation\n\nHere are some examples of negated boolean operations being applied.\n\nNote that we don't use `not` but instead the tilde `~` sign to negate (flip) a value.\n\nNor do we use `and` and `or`; instead we use `&` and `|`.\n\nAlso, expressions join by these operators need to be in parentheses.\n\n## Fancy Indexing\n\nIn so-call fancy indexing, we use array index numbers to access data.\n\nThis can be used to sub-select and re-order data from an array.\n\nWe pass a `list` of item numbers, instead of an integer or integer range with `:`, to the indexer.\n\nThe following says _Select rows 4, 3, 0, and 6, in that order._\n\nAnd we can go backwards.\n\nWe can use lists to perform some complex indexing.\n\n## Transposing Arrays and Swapping Axes\n\nTransposing is a special form of reshaping which similarly returns a view on the underlying data without copying anything. \n\nArrays have the transpose method and also the special `T` attribute:\n\nTransposing is often used when computing the dot product between two arrays.\n\nHere's an example.\n\nFor higher dimensional arrays, `transpose` will accept a tuple of axis numbers to permute the axes.\n\nWarning -- this can get confusing to conceptualize and visualize!\n\nSimple transposing with `.T` is just a special case of swapping axes. ndarray has the method `swapaxes` which takes a pair of axis numbers:\n\n## Universal Functions\n\nA universal function, or `ufunc`, is a function that performs elementwise operations on data in ndarrays. You can think of them as **fast vectorized wrappers for simple functions** that take one or more scalar values and produce one or more scalar results.\n\nMany `ufuncs` are simple elementwise transformations, like `sqrt` or `exp`:\n\n`nan` is a special value in NumPy.\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M05-02-NumpyBasics.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false},"extensions":{"book":{"multiFile":true}}}}}