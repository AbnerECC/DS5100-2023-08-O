{"title":"NB: Getting Started","markdown":{"yaml":{"editor":{"markdown":{"wrap":72}}},"headingText":"NB: Getting Started","containsRefs":false,"markdown":"\n\n\n## Preliminaries\n\n### Installing and Loading Packages\n\nPackages need to be installed once.\n\n```{r}\n## install.packages(\"tm\")  \n```\n\nYou can also install thing using the Package window.\n\nOnce they are installed, you import them with the `library()` function:\n\n```{r}\nlibrary(tm)\n```\n\nNote that the library name is quoted in when installing, but not when\nusing `library`.\n\n### R's Design\n\n-   Designed to support statistical computing\n-   Very strong community\n-   Many domain-specific functions are built in\n-   Vector first thinking\n-   Everything is an object\n\n### R Syntax\n\n-   Syntax loosely follows traditional `C`-style\n    -   **Braces** `{` and `}` are used to form blocks.\n    -   **Semi-colons** are used optionally to end statements, required\n        if on same line.\n-   **Assignments** are made with `<-` or `->`\n-   **Dots** `.` have no special meaning -- they are not operators.\n-   Single and double **quotes** have the same meaning, but double\n    quotes tend to be preferred.\n    -   Use single quotes if you expect your string to contain double\n        quotes.\n\n    -   Backslash escape applies to R strings, although since there are\n        no raw strings -- Python's `r\" \"` -- we often have to supply\n        double backslashes in regular expressions.\\\n\n## R Data Types\n\nThere are several basic R data types.\n\n-   Numeric\n-   Integer\n-   Complex\n-   Logical\n-   Character\n\n### Numeric\n\nDecimal values are called \"numerics\" in R.\n\nIt is the **default** data type.\n\nIf we assign a decimal value to a variable x, x will be of numeric type:\n\n```{r}\nx <- 10.5       # assign a decimal value \nx              # print the value of x \n```\n\n```{r}\nclass(x)      # print the class name of x \n```\n\nEven if we assign an integer to a variable k, it is will still be saved\nas a numeric value.\n\n```{r}\nk <- 1\nk              # print the value of k \n```\n\n```{r}\nclass(k)       # print the class name of k \n```\n\nThat k is not an integer can be confirmed with `is.integer()`:\n\n```{r}\nis.integer(k)  # is k an integer? \n```\n\n### Integers\n\nTo create an integer variable in R, we use `as.integer()`.\n\n```{r}\ny <- as.integer(3) \ny              # print the value of y \n```\n\n```{r}\nclass(y)       # print the class name of y \nis.integer(y)  # is y an integer? \n```\n\nWe can also declare an integer by appending an `L` suffix.\n\n```{r}\ny <- 3L \nis.integer(y)  # is y an integer? \n```\n\nWe can coerce, or cast, a numeric value into an integer with\n`as.integer()`.\n\n```{r}\nas.integer(3.14)    # coerce a numeric value \n```\n\nAnd we can parse a string for decimal values in much the same way.\n\n```{r}\nas.integer(\"5.27\")  # coerce a decimal string \n```\n\nOn the other hand, it is erroneous trying to parse a non-decimal string.\n\n```{r}\nas.integer(\"Joe\")   # coerce an non-decimal string \n```\n\nWe can convert booleans to numbers this way, too.\n\n```{r}\nas.integer(TRUE)    # the numeric value of TRUE \nas.integer(FALSE)   # the numeric value of FALSE \n```\n\n#### Math Operators\n\n| **Operator**   | **Description**             |\n|----------------|-----------------------------|\n| **+**          | addition                    |\n| **-**          | subtraction                 |\n| **\\***         | multiplication              |\n| **/**          | division                    |\n| **\\^ or \\*\\*** | exponentiation              |\n| **x %% y**     | modulus (x mod y) 5%%2 is 1 |\n| **x %/% y**    | integer division 5%/%2 is 2 |\n\n### Logical (Boolean)\n\nA logical value is often created via comparison between variables.\n\n```{r}\nx <- 1\ny <- 2   # sample values \nz <- x > y      # is x larger than y? \nz              # print the logical value \n```\n\n```{r}\nclass(z)       # print the class name of z \n```\n\n#### Logical Operators\n\nStandard logical operations are `&` (and), `|` (or), and `!` (negation).\n\n```{r}\nu <- TRUE\nv <- FALSE\nu & v          # u AND v \n```\n\n```{r}\nu | v          # u OR v \n```\n\n```{r}\n!u             # negation of u \n```\n\nNote that you can use `T` and `F` instead of `TRUE` and `FALSE`.\n\n```{r}\na <- T\nb <- F\na & b\n```\n\n### Characters\n\nA character object is used to represent string values in R.\n\nWe convert objects into character values with the `as.character()`\nfunction:\n\n```{r}\nx <- as.character(3.14) \nx\n```\n\n```{r}\nclass(x)       # print the class name of x \n```\n\n#### `paste()`\n\nTwo character values can be concatenated with the `paste()` function.\n\n```{r}\nfname <- \"Joe\"\nlname <-\"Smith\" \npaste(fname, lname) \n```\n\n`paste()` takes a `sep` argument:\n\n```{r}\npaste(\"A\", \"B\", \"C\", sep=\"--\")\n```\n\n#### `sprintf()`\n\nHowever, it is often more convenient to create a readable string with\nthe `sprintf()` function, which has a C language syntax.\n\n```{r}\nsprintf(\"%s has %d dollars\", \"Sam\", 100) \n```\n\n#### `substr()`\n\nTo extract a substring, we apply the `substr()` function.\n\nHere is an example showing how to extract the substring between the\nthird and twelfth positions in a string.\n\n```{r}\nsubstr(\"Mary has a little lamb.\", start=3, stop=12) \n```\n\n#### `sub()`\n\nAnd to replace the first occurrence of the word \"little\" by another word\n\"big\" in the string, we apply the `sub()` function.\n\n```{r}\nsub(\"little\", \"big\", \"Mary has a little lamb.\") \n```\n\n## R Data Structures\n\nBasic R comes with several data structures:\n\n-   Vector\n-   Matrix\n-   Array\n-   List\n-   Data frame\n\nA **vector** is what is called an array in many other programming\nlanguages\n\n> A collection of cells with **a fixed size** where all cells hold the\n> **same data type** (integers or characters or reals or whatever).\n\nA **matrix** is a two-dimensional vector (fixed size, all cell types the\nsame).\n\nAn **array** is a vector with one or more dimensions.\n\n> So, an array with one dimension is (almost) the same as a vector.\\\n> An array with two dimensions is (almost) the same as a matrix.\\\n> An array with three or more dimensions is an n-dimensional array.\n\nA **list** can hold items of different types and the list size can be\nincreased on the fly.\n\n> List contents can be accessed either by **index** (like `mylist[[1]]`)\n> or by **name** (like `mylist$age`).\n\nA **data frame** is called a *table* in many languages.\n\n> Each column holds the same type, and the columns can have header\n> names.\\\n> A data frame is essential a kind of a list --- **a list of vectors**\n> each with the same length, but of varying data types.\n\n**The two most frequently used are Vector and Data frame.**\n\nSo, we will look at vectors and data frames.\n\n> We will also look at lists since they are used internally to construct\n> data frames.\n\n### Vectors and `c()`\n\nA vector is a sequence of data elements of the **same basic type**.\n\nMembers in a vector are officially called ***components***, but many\ncall them ***members***.\n\nVectors may be created with the `c()` function (\"c\" stands for combine).\n\nHere is a vector of three numeric values 2, 3 and 5.\n\n```{r}\nc(2, 3, 5) \n```\n\nAnd here is a vector of logical values.\n\n```{r}\nc(TRUE, FALSE, TRUE, FALSE, FALSE) \n```\n\nA vector can contain character strings.\n\n```{r}\nc(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\") \n```\n\n#### Vectors from sequences using `:`, `seq()`, and `rep()`\n\nVectors can be made out of sequences which may be generated in a few\nways.\n\n```{r}\ns1 <- 2:5\ns1\n```\n\nThe `seq()` function is like Python's `range()`.\n\n```{r}\ns2 <- seq(from=1, to=5, by=2)  # You can drop the argument names write seq(1,5,2)\ns2\n```\n\nThe `rep()` function will create a series of repeated values:\n\n```{r}\ns3 <- rep(1, 5)\ns3\n```\n\n#### `length()`\n\nThe number of members in a vector is given by the `length()` function.\n\n```{r}\nlength(c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\")) \n```\n\n#### Combining Vectors with `c()`\n\nVectors can be combined via the function `c()`.\n\n```{r}\nn <- c(2, 3, 5) \ns <- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\") \n c(n, s) \n```\n\n#### Value Coercion\n\nNotice how **the numeric values are being coerced into character\nstrings** when the two vectors are combined.\n\nThis is necessary so as to maintain the same primitive data type for\nmembers in the same vector.\n\n#### Vector Math\n\nArithmetic operations of vectors are performed member-by-member, i.e.,\n**member-wise**.\n\nFor example, suppose we have two vectors a and b.\n\n```{r}\na <- c(1, 3, 5, 7) \nb <- c(1, 2, 4, 8)\n```\n\nThen, if we multiply a by 5, we would get a vector with each of its\nmembers multiplied by 5.\n\n```{r}\n5 * a \n```\n\nAnd if we add a and b together, the sum would be a vector whose members\nare the sum of the corresponding members from a and b.\n\n```{r}\na + b\n```\n\nSimilarly for subtraction, multiplication and division, we get new\nvectors via member-wise operations.\n\n```{r}\na - b \n```\n\n```{r}\na * b \n```\n\n```{r}\na / b \n```\n\n#### The Recycling Rule\n\nIf two vectors are of unequal length, the **shorter one will be\nrecycled** in order to match the longer vector.\n\nFor example, the following vectors u and v have different lengths, and\ntheir sum is computed by recycling values of the shorter vector u.\n\n```{r}\nu <- c(10, 20, 30) \nv <- c(1, 2, 3, 4, 5, 6, 7, 8, 9) \nu + v \n```\n\n#### Vector Indexes\n\nWe retrieve values in a vector by declaring an index inside a single\nsquare bracket index `[]` operator.\n\nVector indexes are 1-based.\n\n```{r}\ns <- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\") \ns[3] \n```\n\n#### Negative Indexing\n\nUnlike Python, if the index is negative, **it will remove the member**\nwhose position has the same absolute value as the negative index.\n\nIt really does mean subtraction!\n\nFor example, the following creates a vector slice with the third member\nremoved.\n\n```{r}\ns[-3] \n```\n\n#### Out-of-Range Indexes\n\nValues for out-of-range indexes are reported as NA.\n\n```{r}\ns[10] \n```\n\n#### Numeric Index Vectors\n\nA new vector can be sliced from a given vector with a numeric vector\npassed to the indexing operator.\n\nIndex vectors consist of member positions of the original vector to be\nretrieved.\n\nHere we see how to retrieve a vector slice containing the second and\nthird members of a given vector `s`.\n\n```{r}\ns <- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\") \ns[c(2, 3)] \n```\n\n#### Duplicate Indexes\n\nThe index vector allows duplicate values. Hence the following retrieves\na member twice in one operation.\n\n```{r}\ns[c(2, 3, 3)] \n```\n\n#### Out-of-Order Indexes\n\nThe index vector can even be out-of-order. Here is a vector slice with\nthe order of first and second members reversed.\n\n```{r}\ns[c(2, 1, 3)] \n```\n\n#### Range Index\n\nTo produce a vector slice between two indexes, we can use the colon\noperator \":\". This can be convenient for situations involving large\nvectors.\n\n```{r}\ns[2:4] \n```\n\n#### Logical Index Vectors\n\nA new vector can be sliced from a given vector with a logical index\nvector.\n\nThe logical vector must the same length as the original vector.\n\nIts members are TRUE if the corresponding members in the original vector\nare to be included in the slice, and FALSE if otherwise.\n\n> This is what we called **boolean filtering** and masking in Python.\n\nFor example, consider the following vector s of length 5.\n\n```{r}\ns <- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\")\n```\n\nTo retrieve the the second and fourth members of s, we define a logical\nvector L of the same length, and have its second and fourth members set\nas TRUE.\n\n```{r}\nL = c(FALSE, TRUE, FALSE, TRUE, FALSE)\ns[L] \n```\n\nThe code can be abbreviated into a single line.\n\n```{r}\ns[c(FALSE, TRUE, FALSE, TRUE, FALSE)]\n```\n\n#### Naming Vector Members with `names()`\n\nWe can assign names to vector members.\n\n```{r}\nv <- c(\"Mary\", \"Sue\") \nnames(v) <- c(\"First\", \"Last\") \nv \n```\n\nNow we can retrieve the first member by name.\n\n```{r}\nv[\"First\"] \n```\n\nWe can also reverse the order with a character string index vector.\n\n```{r}\nv[c(\"Last\", \"First\")] \n```\n\n### Lists\n\nA list is a generic vector containing other objects.\n\nThe following variable `x` is a list containing copies of three vectors\n`n`, `s`, `b`, and `a` numeric value 3.\n\n```{r}\nn <- c(2, 3, 5) \ns <- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\") \nb <- c(TRUE, FALSE, TRUE, FALSE, FALSE) \n\nx <- list(n, s, b, 3)   # x contains copies of n, s, b\nx\n```\n\nNote that odd bracket notation.\n\nEach list member **contains** a vector.\n\n#### List Slicing\n\nWe retrieve a list slice with the single square bracket `[]` operator.\n\nThe following is a slice containing the second member of `x`, which is a\ncopy of `s`.\n\n```{r}\nx[2] \n```\n\nWith an index vector, we can retrieve a slice with multiple members.\n\nHere a slice containing the second and fourth members of x.\n\n```{r}\nx[c(2, 4)] \n```\n\n#### Member Reference with `[[]]`\n\nTo reference a list member directly, we use the double square bracket\n`[[]]` operator.\n\nThe following object `x[[2]]` is the second member of `x`.\n\nIn other words, **`x[[2]]` is a copy of `s`, but is not a slice\ncontaining `s` or its copy**.\n\n```{r}\nx[2]\n```\n\n```{r}\nx[[2]]\n```\n\nWe can modify its content directly.\n\n```{r}\nx[[2]][1] = \"ta\" \nx[[2]] \n```\n\nAnd `s` is unaffected.\n\n```{r}\ns \n```\n\n### Data Frames\n\nA data frame is used for storing data tables.\n\nIt is essentially **a list of vectors of equal length**. For example,\nthe following variable df is a data frame containing three vectors `n`,\n`s`, `b`.\n\nYou can think of a data frame is a special kind of list.\n\n```{r}\nn <- c(2, 3, 5) \ns <- c(\"aa\", \"bb\", \"cc\") \nb <- c(TRUE, FALSE, TRUE) \ndf <- data.frame(n, s, b) # df is a data frame\ndf\n```\n\nNotice that data frames are built **column-wise** -- this is true of\nPandas data frames as well.\n\nThe top line of the data frame is the **header**; it contains the column\nnames.\n\nThe data type is list below the column name.\n\nEach horizontal line afterward denotes a data row, which begins with the\nname of the row, and then followed by the actual data.\n\nEach data member of a row is called a cell.\n\n#### Built-in Data Frames\n\nHere is a built-in data frame in R, called `mtcars`.\n\n```{r}\nmtcars \n```\n\nTo retrieve data in a cell, we would enter its **row** and **column**\ncoordinates in the single square bracket `[ ]` operator.\n\nThe two coordinates are separated by a comma, e.g. `[row, col]`.\n\nHere is the cell value from the first row, second column of mtcars.\n\n```{r}\nmtcars[1, 2] \n```\n\nWe can use names instead of the numeric coordinates.\n\n```{r}\nmtcars[\"Mazda RX4\", \"cyl\"] \n```\n\nLastly, the number of data rows in the data frame is given by the\n`nrow()` function.\n\n```{r}\nnrow(mtcars)    # number of data rows \n```\n\nAnd the number of columns of a data frame is given by the `ncol()`\nfunction.\n\n```{r}\nncol(mtcars)    # number of columns \n```\n\n```{r}\ndim(mtcars)\n```\n\nFurther details of the mtcars data set is available in the R\ndocumentation.\n\n```{r}\nhelp(mtcars)\n```\n\n#### Preview with `head()`\n\nInstead of printing out the entire data frame, it is often desirable to\npreview it with the head function beforehand\n\n```{r}\nhead(mtcars) \n```\n\n#### Data Frame Column Vectors\n\nWe reference a data frame column with the double square bracket `[[]]`\noperator, just as we do for lists.\n\nFor example, to retrieve the ninth column vector of the built-in data\nset mtcars, we write mtcars\\[\\[9\\]\\]\n\n```{r}\nmtcars[[9]] \n```\n\nWe can retrieve the same column vector by its name\n\n```{r}\nmtcars[[\"am\"]] \n```\n\nWe can also retrieve with the \"\\$\" operator in lieu of the double square\nbracket operator\n\n```{r}\nmtcars$am \n```\n\nYet another way to retrieve the same column vector is to use the single\nsquare bracket \"\\[\\]\" operator. We prepend the column name with a comma\ncharacter, which signals a wildcard match for the row position\n\n```{r}\nmtcars[, \"am\"] \n```\n\n#### Data Frame Column Slice\n\nWe retrieve a data frame column **slice** with the single square bracket\n`[ ]` operator.\n\nNote: This is like a one-column dataframe in Pandas, as opposed to a\nSeries.\n\n##### Numeric Indexing\n\nThe following is a slice containing the first column of the built-in\ndata set mtcars\n\n```{r}\nmtcars[1] \n```\n\n##### Name Indexing\n\nWe can retrieve the same column slice by its name\n\n```{r}\nmtcars[\"mpg\"] \n```\n\nCompare to accessing the column vector data directly:\n\n```{r}\nmtcars[[\"mpg\"]]\n```\n\nThis is similar to the `.values()` method in Pandas, which returns the\nraw NumPy array\n\nTo retrieve a data frame slice with the two columns mpg and hp, we pack\nthe column names in an index vector inside the single square bracket\noperator\n\n```{r}\nmtcars[c(\"mpg\", \"hp\")] \n```\n\n#### Data Frame Row Slice\n\nWe retrieve rows from a data frame with the single square bracket\noperator, just like what we did with columns. However, in additional to\nan index vector of row positions, we append an extra comma character.\nThis is important, as the extra comma signals a wildcard match for the\nsecond coordinate for column positions.\n\n##### Numeric Indexing\n\nFor example, the following retrieves a row record of the built-in data\nset mtcars. Please notice the extra comma in the square bracket\noperator, and it is not a typo. It states that the 1974 Camaro Z28 has a\ngas mileage of 13.3 miles per gallon, and an eight cylinder 245 horse\npower engine, ..., etc\n\n```{r}\nmtcars[24,] \n```\n\nTo retrieve more than one rows, we use a numeric index vector\n\n```{r}\nmtcars[c(3, 24),] \n```\n\n##### Name Indexing\n\nWe can retrieve a row by its name.\n\n```{r}\nmtcars[\"Camaro Z28\",] \n```\n\nAnd we can pack the row names in an index vector in order to retrieve\nmultiple rows.\n\n```{r}\nmtcars[c(\"Datsun 710\", \"Camaro Z28\"),] \n```\n\n##### Logical Indexing\n\nLastly, we can retrieve rows with a logical index vector. In the\nfollowing vector L, the member value is TRUE if the car has automatic\ntransmission, and FALSE if otherwise.\n\n```{r}\nL <- mtcars$am == 0 \nL \n```\n\nHere is the list of vehicles with automatic transmission\n\n```{r}\nmtcars[L,] \n```\n\nAnd here is the gas mileage data for automatic transmission\n\n```{r}\nmtcars[L,]$mpg \n```\n\n##### Change the name of a column\n\n```{r}\nnames(df)[names(df) == 'old.var.name'] <- 'new.var.name'\n```\n\n#### Importing Data\n\nIt is often necessary to import sample textbook data into R before you\nstart working on your homework.\n\n**Excel Files**\n\nQuite frequently, the sample data is in Excel format, and needs to be\nimported into R prior to use. For this, we can use the function read.xls\nfrom the gdata package. It reads from an Excel spreadsheet and returns a\ndata frame. The following shows how to load an Excel spreadsheet named\n\"mydata.xls\". This method requires Perl runtime to be present in the\nsystem\n\n```{r}\n##library(gdata)                   # load gdata package \n##help(read.xls)                   # documentation \n##mydata <- read.xls(\"mydata.xls\")  # read from first sheet\n```\n\nAlternatively, we can use the function loadWorkbook from the XLConnect\npackage to read the entire workbook, and then load the worksheets with\nreadWorksheet. The XLConnect package requires Java to be pre-installed\n\n```{r}\n##library(XLConnect)               # load XLConnect package \n##wk <- loadWorkbook(\"mydata.xls\") \n##df <- readWorksheet(wk, sheet=\"Sheet1\")\n```\n\n**Table Files**\n\nA data table can resides in a text file.\n\nThe cells inside the table are separated by blank characters.\n\nHere is an example of a table with 4 rows and 3 columns.\n\n```         \n100 a1 b1 \n200 a2 b2 \n300 a3 b3 \n400 a4 b4\n```\n\nNow copy and paste the table above in a file named \"mydata.txt\" with a\ntext editor.\n\nThen load the data into the workspace with the function read.table\n\n```{r}\nmydata <- read.table(\"mydata.txt\")  # read text file \nmydata                             # print data frame \n```\n\n**CSV Files**\n\nThe sample data can also be in comma separated values (CSV) format. Each\ncell inside such data file is separated by a special character, which\nusually is a comma, although other characters can be used as well.\n\nThe first row of the data file should contain the column names instead\nof the actual data. Here is a sample of the expected format.\n\n```         \nCol1,Col2,Col3 \n100,a1,b1 \n200,a2,b2 \n300,a3,b3\n```\n\nAfter we copy and paste the data above in a file named \"mydata.csv\" with\na text editor, we can read the data with the function read.csv\n\n```{r}\nmydata <- read.csv(\"mydata.csv\")  # read csv file \nmydata \n```\n\nIn various European locales, as the comma character serves as the\ndecimal point, the function read.csv2 should be used instead. For\nfurther detail of the read.csv and read.csv2 functions, please consult\nthe R documentation\n\n```{r}\nhelp(read.csv)\n```\n\n#### Working Directory\n\nFinally, the code samples above assume the data files are located in the\nR working directory, which can be found with the function `getwd()`.\n\nNote that these things can also be set using the RStudio's GUI.\n\n```{r}\ngetwd()               # get current working directory\n```\n\nYou can select a different working directory with the function setwd(),\nand thus avoid entering the full path of the data files\n\n```{r}\n## setwd(\"<new path>\")   # set working directory\n```\n\nNote that the forward slash should be used as the path separator even on\nWindows platform\n\n```{r}\n## setwd(\"C:/MyDoc\")\n```\n\n## Extra\n\n### Plots with `plot()`\n\nR is know for its high-quality visualizations, and we'll explore at\nthese in more detail when we look at GGPlot.\n\nFor now, consider the `plot()` function.\n\nLet's plot the data from the built in data frame `airquality`.\n\n```{r}\nairquality\n```\n\n```{r}\nplot(airquality)\n```\n\n```{r}\nplot(airquality[, c(\"Temp\", \"Wind\")])\n```\n\n```{r}\nplot(airquality$Temp, type='l')\n```\n\n```{r}\n?plot\n```\n\n### Value Counts with `table()`\n\nThis function is like `.value_counts()` in Pandas. It does a quick count\nof all the value types of a feature or combination of them.\n\nHere we get a table of values and their counts for `airquality$Temp`,\nconvert this into a data frame, and then plot the results.\n\n```{r}\ntemps <- table(airquality$Temp)\ntemps\n```\n\n```{r}\ntemps.df <- data.frame(temps)\ntemps.df\n```\n\n```{r}\nplot(temps.df, xlab=\"Temp\", type=\"b\")\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M10-01-DataTypesAndStructures.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false,"editor":{"markdown":{"wrap":72}}},"extensions":{"book":{"multiFile":true}}}}}