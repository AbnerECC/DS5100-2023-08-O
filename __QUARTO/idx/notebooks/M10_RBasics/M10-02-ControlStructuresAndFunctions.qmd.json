{"title":"NB: Control Structures and Functions","markdown":{"yaml":{"editor":{"markdown":{"wrap":72}}},"headingText":"NB: Control Structures and Functions","containsRefs":false,"markdown":"\n\n\n## `if`/`else` Statements\n\nYou've seen this in Python.\n\nThey work the same way in both languages.\n\nHere's their syntax in R.\n\n```         \nif(<condition>) {\n        ## do something\n} \n\nif(<condition>) {\n        ## do something\n} \nelse {\n        ## do something else\n}\n\nif(<condition1>) {\n        ## do something\n} else if(<condition2>)  {\n        ## do something different\n} else {\n        ## do something different\n}\n```\n\nGenerate a uniform random number:\n\n```{r}\nx <- runif(1, 0, 10) # From the Uniform Distribution\n\nif(x > 3) {\n  y <- 10\n} else {\n  y <- 0\n}\n\nx\ny\n```\n\nYou assign an `if` statement to a variable.\n\n```{r}\nz <- if(x > 3) {\n  10\n} else { \n  0\n}\n\nz\n```\n\nYou can stack `if` blocks, too.\n\n```         \nif(<condition1>) {\n\n}\n\nif(<condition2>) {\n\n}\n```\n\n## Control Structures\n\n### `for` Loops\n\nFor loops are straight-forward. The take an interator variable, e.g.\n`i`, and assign it successive values from a sequence or vector.\n\nFor loops are often used to iteratE over the elements of an object\n(list, vector, etc.).\n\n```{r}\nfor(i in 1:10) {\n  print(i)\n}\n```\n\nAccording to Hadley Wickham, loops are pretty much the only looping\nconstruct that you will need in R.\n\nThe following three loops all have the same behavior.\n\n```{r}\nx <- c(\"a\", \"b\", \"c\", \"d\")\nfor (i in 1:4) {\n  # Print out each element of 'x'\n  print(x[i])  \n}\n```\n\n### `seq_along()`\n\nThe `seq_along()` function is commonly used in conjunction with for\nloops in order to generate an integer sequence based on the length of an\nobject (in this case, the object x).\n\n```{r}\nx\n```\n\nGenerate a sequence based on length of 'x':\n\n```{r}\nfor(i in seq_along(x)) {   \n  print(x[i])\n}\n```\n\nIt is not necessary to use an index-type variable.\n\n```{r}\nfor(letter in x) {\n  print(letter)\n}\n```\n\nFor one line loops, the curly braces are not strictly necessary.\n\n```{r}\nfor(i in 1:4) print(x[i])\n```\n\n### Nested `for` loops\n\nDor loops can be nested inside of each other.\n\n```{r}\nx <- matrix(1:6, 2, 3)\nfor(i in seq_len(nrow(x))) {\n  for(j in seq_len(ncol(x))) {\n    print(x[i, j])\n  }   \n}\n```\n\nNested loops are used to generate multidimensional or hierarchical data\nstructures (e.g. matrices, lists).\n\n## `while` Loops\n\nAs with Python, while loops start with a condition. It loops while the\ncondition is true and stops when it is false.\n\nRemembe, while loops can go on forever is the truth condition is never\nmet.\n\n```{r}\ncount <- 0\nwhile(count < 10) {\n  print(count)\n  count <- count + 1\n}\n```\n\n## `repeat` Loops\n\n`repeat` loops are using by R. They initiate an infinite loop right from\nthe start.\n\nThe only way to exit a repeat loop is to call break on an internal\ncondition.\n\n```{r eval=FALSE, include=FALSE}\nx0 <- 1\ntol <- 1e-8\n\nrepeat {\n  x1 <- computeEstimate()\n  if (abs(x1 - x0) < tol) {  ## Close enough?\n    break\n  } else {\n    x0 <- x1\n  } \n}\n```\n\n## `next` and `break`\n\nnext is used to skip an iteration of a loop. Same as Python `continue`.\n\n```{r}\nfor (i in 1:100) {\n  if (i <= 20) {\n    # Skip the first 20 iterations\n    next                \n  }      # Do something here\n}\n```\n\n`break` is used to exit a loop immediately.\n\n```{r}\nfor (i in 1:100) {\n  print(i)\n  if (i > 20) {\n    # Stop loop after 20 iterations\n    break  \n  }     \n}\n```\n\n## Functions\n\nDefine some data\n\n```{r}\nx <- 5                \nxx <- c(4, 6, 7, 8, 2, 11)\n```\n\nNow, define a function that does the following: - takes a value, vector\nof values as inputs - normalizes the value against the vector by\nsubtracting the vector mean from value, and dividing by vector standard\ndeviation.\n\n```{r}\ncompute_zscore <- function(val, vec) {\n  z <- (val - mean(vec)) / sd(vec)\n}\n\nprint(compute_zscore(x, xx))\n```\n\nIf vector contains identical values, `sd` is zero, and so the z-score is\nundefined.\n\n```{r}\nprint(compute_zscore(x, c(1, 1, 1, 1)))\n```\n\nIf vector contains missing values, the result will be `NA`.\n\n```{r}\nxx_na <- c(1, NA, 3, 5) \nprint(compute_zscore(x, xx_na))\n```\n\n## Using conditions in functions\n\nA function returns 1 if passed value is odd, 0 if even\n\n## %% is mod operator (returns remainder)\n\n```{r}\nis_odd <- function(x){ if (x %% 2 == 1) { \n    return(1) \n  } else { \n    return(0)\n  } \n}\n```\n\nCall to test some cases:\n\n```{r}\nis_odd(4)\nis_odd(3)\n```\n\nFunction arguments can use default values:\n\n```{r}\nthreshold_vals <- function(p, thresh = 0.5) {\n  # for each element in p, returns TRUE if value > thresh, else FALSE\n  p > thresh\n}\n```\n\n```{r}\nthreshold_vals(c(0.6, 0.4, 0.1, 1))\n```\n\nNow, pass a threshhold:\n\n```{r}\nthreshold_vals(c(0.6, 0.4, 0.1, 1), 0.7)\n```\n\nAssert important preconditions\n\n```{r}\nadd_vectors <- function(x, y) {\n  # assert the lengths of vectors x and y match\n  # if they do, sum elementwise, else throw error with stop()\n\n  if (length(x) != length(y)) {\n    stop(\"x and y must be the same length\", call. = FALSE)\n  }\n  x + y\n}\n```\n\n```{r}\nadd_vectors(c(1, 2, 3), c(3, 3, 3))\n```\n\n```{r}\n#| eval: false\nadd_vectors(c(1, 2, 3), c(3, 3, 3, 3)) # breaks\n```\n\n## Scoping Rules\n\n```{r}\nz <- 4\ntest_fcn <- function(x) {\n  x^z\n}\n```\n\nNow look at this:\n\n```{r}\ntest_fcn(2)\n```\n\nIf `z` isn't defined in the function, how does this work?\n\nR's scoping rules are similar to Python's.\n\nSince `z` isn't in the function, **R looks in the function's\nenvironment** for it.\n\nFor more on scoping rules, see [Chapter 15: Scoping Rules of\nR](https://bookdown.org/rdpeng/rprogdatascience/scoping-rules-of-r.html)\nin Peng's *R Programming For Data Science*.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M10-02-ControlStructuresAndFunctions.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false,"editor":{"markdown":{"wrap":72}}},"extensions":{"book":{"multiFile":true}}}}}