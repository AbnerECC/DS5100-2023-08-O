{"title":"NB: GGPlot2","markdown":{"yaml":{"editor":{"markdown":{"wrap":72}}},"headingText":"NB: GGPlot2","containsRefs":false,"markdown":"\n\n\n## Introduction\n\nToday we'll look at GGPlot2, the graphics package associated with the\n**Tidyverse**.\n\n## Learning Goal\n\nYou will be introduced into how and why to use **visualizations** in DS\n6001.\n\n-   Visualizations in EDA.\n\n-   Visualization in creating data products that **communicate**\n    results, such as scientific publications, infographics, and\n    interactive visualizations.\n\nThese things come at the end of the data science **pipeline**.\n\nToday, I just want to introduce you to the thinking and **design logic**\nbehind the package, so you can be confident in learning more as you need\nto.\n\n## The Grammar of Graphics\n\nAs with Dplyr, GGPlot2 is a an entirely new system that **supplants**\nthe older graph functions that are built into R.\n\nAnd just as with Dplyr, it is founded on a principled analysis of its\ndomain and approaches code design through developing a basic **grammar**\nwhich can then be expressed in R.\n\nIn effect, Dplyr is built on a **grammar of data** by defining a set of\n**verbs** that can be used to build phrases that are put together into\nlarger constructs.\n\nThese verbs correspond to a **process** of data transformation.\n\nGGPlot2 is built on a **grammar of graphics** that defines a set of\n**nouns** that correspond to **the architecture of a graphic** (aka\nplot).\n\nThe phrase \"grammar of graphics\" actually comes from the book by that\nname written by statistician and computer scientist **Leland Wilkinson**\nin 1999 and later revised:\n\n[![The Second\nEdition](images/paste-39DF579F.png)](https://www.google.com/books/edition/The_Grammar_of_Graphics/YGgUswEACAAJ?hl=en)\n\nIt's worth reading if you want to get a solid grounding in\nvisualization, which belongs to the **design area of data science**.\n\n## A Layered Model\n\nWilkinson takes an **object-oriented approach** to visualization and\nformalizes two main **principles**:\n\nI.  **Graphics** are built out of distinct ***layers*** of grammatical\n    **elements.**\nII. In each layer, meaningful **plots** are constructed through\n    **mappings of data onto aesthetics.**\n\nThe essential grammatical elements to create any visualization are:\n\n![](images/paste-E167991C.png)\n\nAccording to Wickham, who adopted these principles and applied them to\nR,\n\n> A grammar of graphics is a tool that enables us to **concisely\n> describe the components of a graphic**. Such a grammar allows us to\n> **move beyond named graphics** (e.g., the \"scatterplot\") and gain\n> insight into **the deep structure** that underlies statistical\n> graphics ([Wickham\n> 2012](https://www.tandfonline.com/doi/abs/10.1198/jcgs.2009.07098)).\n\nWickham takes this idea and develops it into this:\n\n![](images/paste-D2214B2A.png)\n\n[Source](https://blog.gramener.com/grammar-of-graphics-data-stories/)\n(see also\n[ScienceCraft](https://www.science-craft.com/2014/07/08/introducing-the-grammar-of-graphics-plotting-concept/)).\n\nYou can see that everything starts with **data.**\n\nThen data are mapped on **aesthetics** within **geometries.**\n\n-   **Geometries** are geometric things like points, lines, and bars.\n\n-   **Aesthetics** are visual things like position, size, color and\n    shape.\n\nYou can see how the latter are properties of the former.\n\nAlso note that aesthetics make use of visual channels to signify\n\n-   Size can mean greater than, which is good for numeric scale but not\n    categories\n\n-   Color can signify things like value, e.g. via\n    `red : dangerous : : green : safe`.\n\nThese are the primary layers.\n\nThe other layers apply **downstream modifications** that add more\n**information** and **style** to the graph.\n\n## The Bare Minimum\n\nEverything starts with `ggplot()` which is part of the Tidyverse.\n\n```{r}\nlibrary(tidyverse)\n```\n\nHere is a basic graph -- a scatterplot comparing two features in the\niris dataset. I've broken out the functions and arguments so you can see\nhow the grammar is implemented:\n\n```{r}\niris %>%\nggplot(\n  mapping = aes(\n    x = Sepal.Length, \n    y = Sepal.Width)\n  ) + \n  geom_point(size=3, aes(color=Species))\n```\n\n`ggplot()` starts by creating a **coordinate system** that you can add\n**layers** to.\n\n-   The **coordinate system** can be changed after the graph is\n    initiated.\n\nThese **layers** are created by **geometry functions.**\n\n-   For example, `geom_point` creates a point-based visualization.\n-   There are many `geom_` functions, and they can be layered on top of\n    each other:\n    -   `geom_point()`\n    -   `geom_bar()`\n    -   `geom_histogram()`\n    -   `geom_boxplot()`\n    -   etc.\n\nHere we have a plot with two layers. The second layer is created by a\n**stat** function, which is similar to geom, but applies a statistical\ntransformation to the data.\n\n```{r}\niris %>%\nggplot(aes(\n  x = Sepal.Length, \n  y = Sepal.Width)) + \n  geom_point(size=3, aes(color=Species)) + \n  stat_smooth(method = lm)\n```\n\nThe core the process is that each layer **maps** **data** onto what are\ncalled **aesthetics (`aes`).**\n\nAesthetics are **visual objects and properties** that can used to\nrepresent numeric and categorical values\n\n-   x and y positions (in a two-dimensional system)\n-   Color\n-   Size\n-   Shape\n-   Text\n\nIn addition to these elements, ggplot also provides **faceting**, which\nis the visual equivalent of grouping by. Just as with group by, a data\nfeature is used to divide the visualization into groups, each taking the\nsame form but showing a different subset of data.\n\n```{r}\niris %>%\nggplot(aes(\n  x = Sepal.Length, \n  y = Sepal.Width)) + \n  geom_point(size=3, aes(color=Species)) + \n  stat_smooth(method = lm) +\n  facet_wrap(facets = vars(Species))\n```\n\n> By the way, this is an example of Simpson's Paradox. The overall trend\n> is downward, but each group trend upward.\n\n```{r}\niris %>%\n  ggplot(aes(\n    x = Sepal.Length, \n    y = Sepal.Width)) + \n    geom_point(size=3, aes(color=Species)) + \n    stat_smooth(method = lm) +\n    stat_smooth(method = lm, se=FALSE, aes(color=Species))\n```\n\nAnyway, the **general structure** of a ggplot statement is the\nfollowing:\n\n```         \nggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(\n     mapping = aes(<MAPPINGS>),\n     stat = <STAT>, \n     position = <POSITION>\n  ) +\n  <COORDINATE_FUNCTION> +\n  <FACET_FUNCTION>\n```\n\n## The `+` operator\n\nYou will notice the use of the `+` operator to connect ggplot functions\ntogether to produce a final product. Theses are not quite the same as\npipes `%>%`.\n\nThe difference is that pipes feed data from one function to another,\nwhereas the `+` operation combines elements to produce an increasingly\ndeveloped visualization.\n\nAnother thing to keep in mind: the `+` always goes at the **end of a\nline**, not at the beginning.\n\n# Examples\n\nLet look at how to build out graphics using the built-in diamonds data.\n\n```{r}\ndiamonds\n```\n\n```{r}\ndiamonds %>%\n    ggplot(aes(x=carat, y=price)) + \n    geom_point()\n```\n\nHere's another way to construct a graphic. By assigning it a variable,\nwe can keep adding to it and showing out work.\n\n```{r}\ngg <- ggplot(diamonds, aes(x=carat, y=price)) \ngg + geom_point()\n```\n\n`stroke` controls the thickness of point boundary\n\n```{r}\ngg + geom_point(\n  size=1, \n  shape=1, \n  color=\"steelblue\", \n  stroke=2)  \n```\n\nLet's map the variables carat, cut and color to various aesthetics in\nour geometry function:\n\n```{r}\ngg + geom_point(aes(\n  size=carat, \n  shape=cut, \n  color=color, \n  stroke=carat))\n```\n\n## Add Title, X and Y axis labels with `labs()`\n\n```{r}\ngg1 <- gg + geom_point(aes(color=color))\ngg2 <- gg1 + labs(title=\"Diamonds\", x=\"Carat\", y=\"Price\") \ngg2\n```\n\n## Change color of all text with `theme()`\n\n```{r}\ngg2 + theme(text=element_text(color=\"blue\"))  # all text turns blue.\n```\n\n## Change title, X and Y axis label and text size\n\n-   `plot.title`: Controls plot title.\n-   `axis.title.x`: Controls X axis title\n-   `axis.title.y`: Controls Y axis title\n-   `axis.text.x`: Controls X axis text\n-   `axis.text.y`: Controls y axis text\n\n```{r}\ngg3 <- gg2 + \n  theme(plot.title=element_text(size=25), \n        axis.title.x=element_text(size=20),\n        axis.title.y=element_text(size=20),\n        axis.text.x=element_text(size=15),\n        axis.text.y=element_text(size=15)\n        )\ngg3\n```\n\n## Change title face, color, line height\n\n```{r}\ngg3 + \n  labs(title = \"Plot Title\\nSecond Line of Plot Title\") +\n  theme(plot.title = element_text(\n    face=\"bold\", \n    color=\"steelblue\", \n    lineheight=1.2)\n  )\n```\n\n## Change point color\n\n```{r}\ngg3 + scale_colour_manual(\n  name='Legend', \n  values=c('D'='grey', \n           'E'='red', \n           'F'='blue', \n           'G'='yellow', \n           'H'='black', \n           'I'='green', \n           'J'='firebrick'))\n```\n\n## Adjust X and Y axis limits\n\nMethod 1: Zoom in\n\n```{r}\ngg3 + \n    coord_cartesian(xlim=c(0,3), ylim=c(0, 5000)) + \n    geom_smooth()  # zoom in\n```\n\nMethod 2: Deletes the points outside limits\n\n```{r}\ngg3 + \n  xlim(c(0,3)) + \n  ylim(c(0, 5000)) + \n  geom_smooth()  # deletes the points \n```\n\nMethod 3: Deletes the points outside limits\n\n```{r}\ngg3 + scale_x_continuous(limits=c(0,3)) + \n  scale_y_continuous(limits=c(0, 5000)) +\n  geom_smooth()  # deletes the points outside limits\n```\n\nNotice the change in smoothing line because of deleted points. This\ncould sometimes be misleading in your analysis.\n\n## Change X and Y axis labels\n\n```{r}\ngg3 + scale_x_continuous(\n  labels=c(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\")) \n  scale_y_continuous(breaks=seq(0, 20000, 4000))  # if Y is continuous, if X is a factor\n```\n\nUse scale_x_discrete instead, if X variable is a factor.\n\nRotate axis text\n\n```{r}\ngg3 + theme(axis.text.x=element_text(angle=45), axis.text.y=element_text(angle=45))\n```\n\n## Flip X and Y Axis\n\n```{r}\ngg3 + coord_flip()  # flips X and Y axis.\n```\n\n## Grid lines and panel background\n\n```{r}\ngg3 + theme(panel.background = element_rect(fill = 'springgreen'),\n  panel.grid.major = element_line(colour = \"firebrick\", size=3),\n  panel.grid.minor = element_line(colour = \"blue\", size=1))\n```\n\n## Plot margin and background\n\n```{r}\ngg3 + theme(plot.background=element_rect(fill=\"yellowgreen\"), plot.margin = unit(c(2, 4, 1, 3), \"cm\")) # top, right, bottom, left\n```\n\n# Legend\n\n## Hide legend\n\n```{r}\ngg3 + theme(legend.position=\"none\")  # hides the legend\n```\n\n## Change legend title\n\n```{r}\ngg3 + scale_color_discrete(name=\"\")  # Remove legend title (method1)\n\n# Remove legend title (method)\np1 <- gg3 + theme(legend.title=element_blank())  \n\n# Change legend title\np2 <- gg3 + scale_color_discrete(name=\"Diamonds\")  \n```\n\n```{r}\n# install.packages(\"gridExtra\")\n```\n\n```{r}\nlibrary(gridExtra)\ngrid.arrange(p1, p2, ncol=2)  # arrange\n```\n\n## Change legend and point color\n\n```{r}\ngg3 + scale_colour_manual(name='Legend', values=c('D'='grey', 'E'='red', 'F'='blue', 'G'='yellow', 'H'='black', 'I'='green', 'J'='firebrick'))\n```\n\n## Change legend position\n\nOutside plot\n\n```{r}\np1 <- gg3 + theme(legend.position=\"top\")  # top / bottom / left / right\n```\n\nInside plot\n\n```{r}\np2 <- gg3 + theme(legend.justification=c(1,0), legend.position=c(1,0))  # legend justification is the anchor point on the legend, considering the bottom left of legend as (0,0)\ngridExtra::grid.arrange(p1, p2, ncol=2)\n```\n\n## Change order of legend items\n\n```{r}\n#df$newLegendColumn <- factor(df$legendcolumn, levels=c(new_order_of_legend_items), ordered = TRUE) \n```\n\nCreate a new factor variable used in the legend, ordered as you need.\nThen use this variable instead in the plot.\n\n## Legend title, text, box, symbol\n\n-   `legend.title` - Change legend title\n-   `legend.text` - Change legend text\n-   `legend.key` - Change legend box\n-   `guides` - Change legend symbols\n\n```{r}\ngg3 + theme(legend.title = element_text(size=20, color = \"firebrick\"), legend.text = element_text(size=15), legend.key=element_rect(fill='steelblue')) + guides(colour = guide_legend(override.aes = list(size=2, shape=4, stroke=2)))  # legend title color and size, box color, symbol color, size and shape.\n```\n\n# Plot text and annotation\n\n## Add text in chart\n\n```{r}\n# Not Run: gg + geom_text(aes(xcol, ycol, label=round(labelCol), size=3)) \n# general format \ngg + geom_text(aes(label=color, color=color), size=4)\n```\n\n##Annotation\n\n```{r}\nlibrary(grid) \nmy_grob = grobTree(textGrob(\"My Custom Text\", x=0.8, y=0.2, \n                            gp=gpar(col=\"firebrick\", fontsize=25, fontface=\"bold\"))) \n\ngg3 + annotation_custom(my_grob)\n```\n\n# Multiple plots\n\n## Multiple chart panels\n\n```{r}\np1 <- gg1 + facet_grid(color ~ cut) # arrange in a grid. More space for plots. Free X and Y axis scales\n```\n\nBy setting scales='free', the scales of both X and Y axis is freed. Use\nscales='free_x' to free only X-axis and scales='free_y' to free only\nY-axis.\n\n```{r}\np2 <- gg1 + facet_wrap(color ~ cut, scales=\"free\") # free the x and yaxis scales. \n```\n\n## Arrange multiple plots\n\n```{r}\nlibrary(gridExtra) \ngrid.arrange(p1, p2, ncol=2)\n```\n\n# Geom layers\n\n## Add smoothing line\n\n```{r}\ngg3 + geom_smooth(aes(color=color)) # method could be - 'lm', 'loess', 'gam'\n```\n\n## Add horizontal / vertical line\n\n```{r}\np1 <- gg3 + geom_hline(yintercept=5000, size=2, linetype=\"dotted\", color=\"blue\") # linetypes: solid, dashed, dotted, dotdash, longdash and twodash \np2 <- gg3 + geom_vline(xintercept=4, size=2, color=\"firebrick\") \np3 <- gg3 + geom_segment(aes(x=4, y=5000, xend=4, yend=10000, size=2, lineend=\"round\")) \np4 <- gg3 + geom_segment(aes(x=carat, y=price,\nxend=carat, yend=price-500, color=color), size=2) + coord_cartesian(xlim=c(3, 5)) # x, y: start points. xend, yend: endpoints \ngridExtra::grid.arrange(p1,p2,p3,p4, ncol=2)\n```\n\n## Add bar chart\n\n```{r}\n# Frequency bar chart: Specify only X axis. \ngg <- ggplot(mtcars, aes(x=cyl)) \ngg + geom_bar() # frequency table\n```\n\n```{r}\ngg <- ggplot(mtcars, aes(x=cyl)) \np1 <- gg + geom_bar(position=\"dodge\", aes(fill=factor(vs))) # side-by-side \np2 <- gg + geom_bar(aes(fill=factor(vs))) # stacked \ngridExtra::grid.arrange(p1, p2, ncol=2)\n\n```\n\n```{r}\n# Absolute bar chart: Specify both X adn Y axis. Set stat=\"identity\"\ndf <- aggregate(mtcars$mpg, by=list(mtcars$cyl), FUN=mean)  # mean of mpg for every 'cyl'\nnames(df) <- c(\"cyl\", \"mpg\")\nhead(df)\n#>   cyl    mpg\n#> 1   4  26.66\n#> 2   6  19.74\n#> 3   8  15.10\n\ngg_bar <- ggplot(df, aes(x=cyl, y=mpg)) + geom_bar(stat = \"identity\")  # Y axis is explicit. 'stat=identity'\nprint(gg_bar)\n```\n\n## Distinct color for bars\n\n```{r}\ngg_bar <- ggplot(df, aes(x=cyl, y=mpg)) + geom_bar(stat = \"identity\", aes(fill=cyl))\nprint(gg_bar)\n```\n\n## Change color and width of bars\n\n```{r}\ndf$cyl <- as.factor(df$cyl)\ngg_bar <- ggplot(df, aes(x=cyl, y=mpg)) + geom_bar(stat = \"identity\", aes(fill=cyl), width = 0.25)\ngg_bar + scale_fill_manual(values=c(\"4\"=\"steelblue\", \"6\"=\"firebrick\", \"8\"=\"darkgreen\"))\n```\n\n## Change color palette\n\n```{r}\nlibrary(RColorBrewer)\ndisplay.brewer.all(n=20, exact.n=FALSE)  # display available color palettes\nggplot(mtcars, aes(x=cyl, y=carb, fill=factor(cyl))) + geom_bar(stat=\"identity\") + scale_fill_brewer(palette=\"Reds\")  # \"Reds\" is palette name\n```\n\n# Line chart\n\n```{r}\n# Method 1:\ngg <- ggplot(economics, aes(x=date))  # setup\ngg + geom_line(aes(y=psavert), size=2, color=\"firebrick\") + geom_line(aes(y=uempmed), size=1, color=\"steelblue\", linetype=\"twodash\")  # No legend\n# available linetypes: solid, dashed, dotted, dotdash, longdash and twodash\n\n```\n\n```{r}\n# Method 2:\n#install.packages(\"reshape2\")\nlibrary(reshape2)\ndf_melt <- melt(economics[, c(\"date\", \"psavert\", \"uempmed\")], id=\"date\")  # melt by date. \ngg <- ggplot(df_melt, aes(x=date))  # setup\ngg + geom_line(aes(y=value, color=variable), size=1) + scale_color_discrete(name=\"Legend\")  # gets legend.\n```\n\n## Line chart from timeseries\n\n```{r}\n# One step method.\n# install.packages(\"ggfortify\")\nlibrary(ggfortify)\nautoplot(AirPassengers, size=2) + labs(title=\"AirPassengers\")\n```\n\n# Ribbons\n\nFilled time series can be plotted using geom_ribbon(). It takes two\ncompulsory arguments ymin and ymax.\n\n```{r}\n# Prepare the dataframe\nst_year <- start(AirPassengers)[1]\nst_month <- \"01\"\nst_date <- as.Date(paste(st_year, st_month, \"01\", sep=\"-\"))\ndates <- seq.Date(st_date, length=length(AirPassengers), by=\"month\")\ndf <- data.frame(dates, AirPassengers, AirPassengers/2)\nhead(df)\n#>        dates AirPassengers AirPassengers.2\n#> 1 1949-01-01           112            56.0\n#> 2 1949-02-01           118            59.0\n#> 3 1949-03-01           132            66.0\n#> 4 1949-04-01           129            64.5\n#> 5 1949-05-01           121            60.5\n#> 6 1949-06-01           135            67.5\n# Plot ribbon with ymin=0\ngg <- ggplot(df, aes(x=dates)) + labs(title=\"AirPassengers\") + theme(plot.title=element_text(size=30), axis.title.x=element_text(size=20), axis.text.x=element_text(size=15))\ngg + geom_ribbon(aes(ymin=0, ymax=AirPassengers)) + geom_ribbon(aes(ymin=0, ymax=AirPassengers.2), fill=\"green\")\n```\n\n```{r}\ngg + geom_ribbon(aes(ymin=AirPassengers-20, ymax=AirPassengers+20)) + geom_ribbon(aes(ymin=AirPassengers.2-20, ymax=AirPassengers.2+20), fill=\"green\")\n```\n\n## Area\n\ngeom_area is similar to geom_ribbon, except that the ymin is set to 0.\nIf you want to make overlapping area plot, use the alpha aesthetic to\nmake the top layer translucent.\n\n```{r}\n# Method1: Non-Overlapping Area\ndf <- reshape2::melt(economics[, c(\"date\", \"psavert\", \"uempmed\")], id=\"date\")\nhead(df, 3)\n#>         date variable value\n#> 1 1967-07-01  psavert  12.5\n#> 2 1967-08-01  psavert  12.5\n#> 3 1967-09-01  psavert  11.7\np1 <- ggplot(df, aes(x=date)) + geom_area(aes(y=value, fill=variable)) + labs(title=\"Non-Overlapping - psavert and uempmed\")\n\n# Method2: Overlapping Area\np2 <- ggplot(economics, aes(x=date)) + geom_area(aes(y=psavert), fill=\"yellowgreen\", color=\"yellowgreen\") + geom_area(aes(y=uempmed), fill=\"dodgerblue\", alpha=0.7, linetype=\"dotted\") + labs(title=\"Overlapping - psavert and uempmed\")\ngridExtra::grid.arrange(p1, p2, ncol=2)\n```\n\n# Boxplot and Violin\n\nThe oulier points are controlled by the following aesthetics:\n\n-   outlier.shape\n-   outlier.stroke\n-   outlier.size\n-   outlier.colour\n\nIf the notch is turned on (by setting it TRUE), the below boxplot is\nproduced. Else, you would get the standard rectangular boxplots.\n\n```{r}\np1 <- ggplot(mtcars, aes(factor(cyl), mpg)) + geom_boxplot(aes(fill = factor(cyl)), width=0.5, outlier.colour = \"dodgerblue\", outlier.size = 4, outlier.shape = 16, outlier.stroke = 2, notch=T) + labs(title=\"Box plot\")  # boxplot\np2 <- ggplot(mtcars, aes(factor(cyl), mpg)) + geom_violin(aes(fill = factor(cyl)), width=0.5, trim=F) + labs(title=\"Violin plot (untrimmed)\")  # violin plot\ngridExtra::grid.arrange(p1, p2, ncol=2)\n```\n\n# Density\n\n```{r}\nggplot(mtcars, aes(mpg)) + geom_density(aes(fill = factor(cyl)),\nsize=2) + labs(title=\"Density plot\") \n```\n\n# Tiles\n\n```{r}\ncorr <- round(cor(mtcars), 2)\ndf <- reshape2::melt(corr)\ngg <- ggplot(df, aes(x=Var1, y=Var2, fill=value, label=value)) + geom_tile() + theme_bw() + geom_text(aes(label=value, size=value), color=\"white\") + labs(title=\"mtcars - Correlation plot\") + theme(text=element_text(size=20), legend.position=\"none\")\n\nlibrary(RColorBrewer)\np2 <- gg + scale_fill_distiller(palette=\"Reds\")\np3 <- gg + scale_fill_gradient2()\ngridExtra::grid.arrange(gg, p2, p3, ncol=3)\n```\n\n> <http://r-statistics.co/ggplot2-cheatsheet.html>\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M12-01-GGPlot.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false,"editor":{"markdown":{"wrap":72}}},"extensions":{"book":{"multiFile":true}}}}}