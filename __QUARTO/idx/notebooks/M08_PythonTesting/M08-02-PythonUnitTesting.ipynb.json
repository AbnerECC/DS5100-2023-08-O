{"title":"NB: Unit Testing with Unittest","markdown":{"headingText":"NB: Unit Testing with Unittest","containsRefs":false,"markdown":"\n\n## Unit Testing\n\nUnit testing is a testing technique in which **individual modules are tested** to determine if there are any issues by the developer himself. \n\nIt is concerned with **functional correctness** of the stand-alone modules.\n\nThe main aim is to **isolate each unit** of the system to identify, analyze and fix the defects.\n\nThese units are typicallly functions and methods.\n\n## Benefits of Unit Testing\n\nDevelopers can work in a **predictable** way on developing code.\n\nDevelopers can **write their own unit tests**.\n\nYou can get **a rapid response** for testing small changes\n\nAlso:\n\nReduces **defects in the newly developed features** or reduces bugs when changing the existing functionality.\n\nReduces **cost of testing**, since defects are captured in very early phase.\n\n**Improves design** and allows better refactoring of code.\n\nTesting in Python is a huge topic and can come with a lot of complexity, but it doesn’t need to be hard. You can get started creating simple tests for your application in a few easy steps and then build on it from there.\n\n## The `unittest` Framework\n\nOne of the popular unit testing frameworks is Unittest. It is works well and is easy to use.\n\nThere are other tools, though -- here's [a comparison of 6 Python testing frameworks](https://www.softwaretestinghelp.com/python-testing-frameworks/).\n\n## The Basic Idea\n\nThe Unittest framework provides you with **a bunch of `assert` methods**, which are essentially wrappers around Python's built-in `assert` function. \n\nThe basic idea is to **write functions that test other functions** by using these assert methods **instead of peppering your code** with them.\n\nUnittest provides **many assert methods** -- see this [cheat sheet](https://kapeli.com/cheat_sheets/Python_unittest_Assertions.docset/Contents/Resources/Documents/index) for more.\n\nWe will focus on three:\n* `assertTrue()`\n* `assertFalse()`\n* `assertEqual()`\n\n## The Basic Pattern\n\nThe Unittest framework works as follows:\n\n**Choose** on a method or class that you want to test.\n\n**Create a class** that is a subclass of `unittest.TestCase`.\n\nIn that class **write methods** that are designed to test the behavior of methods in the code you want to test.\n\n  - These **test methods** focus on one behavior of one method (or function).\n  - There can be **many test methods** for each target method.\n  - Each test method name must be prefixed by **`test_`**.\n  - Tests are executing in alphabetical order, so name them in the order you want them executed.\n  - Each test makes use of an **assert method**. These methods typically compare **expected** with **actual** methods and return `False` if they don't match and `True` if they do.\n   - You always want tests to pass, so if you want to test if something breaks, you return `True` for a `False` condition.\n\n**Run** the script and see the results.\n\n**Update** the script as you create new methods or refactor existing ones.\n\n## Assert Methods\n\n### `.assertTrue()`\n\n#### Negative Test Case \n\nRun `M08-02-script1.py`\n\n```python\nclass TestStringMethods(unittest.TestCase):\n\n    # test function\n    def test_negative(self):\n\n        testValue = False\n        \n        # error message in case if test case got failed\n        message = \"Test value is not true.\"\n        \n        # assertTrue() to check true of test value\n        self.assertTrue(testValue, message)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n#### Positive Test Case\n\n```python\nimport unittest\n\nclass TestStringMethods(unittest.TestCase):\n    \n    # test function\n    def test_positive(self):\n        \n        testValue = True\n        \n        # error message in case if test case got failed\n        message = \"Test value is not true.\"\n        \n        # assertTrue() to check true of test value\n        self.assertTrue( testValue, message)\n\nif __name__ == '__main__':\n\tunittest.main()\n```\n\n### `.assertFalse()`\n\n#### Negative Test Case\n\n```python\nimport unittest\n\nclass TestStringMethods(unittest.TestCase):\n\t# test function\n\tdef test_negative(self):\n\t\ttestValue = True\n\t\t# error message in case if test case got failed\n\t\tmessage = \"Test value is not false.\"\n\t\t# assetFalse() to check test value as false\n\t\tself.assertFalse( testValue, message)\n\nif __name__ == '__main__':\n\tunittest.main()\n```\n\n#### Positive Test Case\n\n```python\n## unit test case\nimport unittest\n\nclass TestStringMethods(unittest.TestCase):\n\t# test function\n\tdef test_positive(self):\n\t\ttestValue = False\n\t\t# error message in case if test case got failed\n\t\tmessage = \"Test value is not false.\"\n\t\t# assertFalse() to check test value as false\n\t\tself.assertFalse( testValue, message)\n\nif __name__ == '__main__':\n\tunittest.main()\n```\n\n### `.assertEqual()`\n\nHere is a case where we expect two values to be equal.\n\n#### Negative Test Case\n\n```python\n## unit test case\nimport unittest\n\nclass TestStringMethods(unittest.TestCase):\n\t# test function to test equality of two value\n\tdef test_negative(self):\n\t\tfirstValue = \"geeks\"\n\t\tsecondValue = \"gfg\"\n\t\t# error message in case if test case got failed\n\t\tmessage = \"First value and second value are not equal !\"\n\t\t# assertEqual() to check equality of first & second value\n\t\tself.assertEqual(firstValue, secondValue, message)\n\nif __name__ == '__main__':\n\tunittest.main()\n```\n\n#### Positive Test Case\n\n```python\n## unit test case\nimport unittest\n\nclass TestStringMethods(unittest.TestCase):\n\t# test function to test equality of two value\n\tdef test_positive(self):\n\t\tfirstValue = \"geeks\"\n\t\tsecondValue = \"geeks\"\n\t\t# error message in case if test case got failed\n\t\tmessage = \"First value and second value are not equal !\"\n\t\t# assertEqual() to check equality of first & second value\n\t\tself.assertEqual(firstValue, secondValue, message)\n\nif __name__ == '__main__':\n\tunittest.main(verbosity=2)\n```\n\n## Example with User-defined Function\n\n**Function to test**\n\n```python\ndef add_fish_to_aquarium(fish_list):\n    if len(fish_list) > 10:\n        raise ValueError(\"A maximum of 10 fish can be added to the aquarium\")\n    return {\"tank_a\": fish_list}\n\nimport unittest\n```\n\n**Class to test the function**\n\n```python\nclass TestAddFishToAquarium(unittest.TestCase):\n    \n    def test_add_fish_to_aquarium_success(self):\n        actual = add_fish_to_aquarium(fish_list=[\"shark\", \"tuna\"])\n        expected = {\"tank_a\": [\"shark\", \"tuna\"]}\n        self.assertEqual(actual, expected)\n\n    def test_add_fish_to_aquarium_exception(self):\n        too_many_fish = [\"shark\"] * 25\n        with self.assertRaises(ValueError) as exception_context:\n            add_fish_to_aquarium(fish_list=too_many_fish)\n        self.assertEqual(\n            str(exception_context.exception),\n            \"A maximum of 10 fish can be added to the aquarium\"\n        )\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)\n```\n\n## Example with External Class\n\nWe create a class called `Student` and save it in a local file called `student.py`.\n\n```python\nclass Student:\n    \n    # constructor\n    def __init__(self, name, courses=None):\n        self.name = name # string type\n        self.courses = [] if courses is None else courses # list of strings\n        self.num_courses = len(self.courses)\n        \n    # enroll in a course\n    def enroll_in_course(self, course_name): \n        self.courses.append(course_name)\n        self.num_courses += 1 # increment the number of courses\n```\n\nThen we create a companion test file for our class, saving it in a file called `student_test.py`.\n\n```python\nfrom student import Student\nimport unittest\n\nclass EnrollInTestCase(unittest.TestCase): \n    \n    def test_is_incremented_correctly(self):\n        # test if enrollInCourse() method successfully increments the\n        # num_courses attribute of the Student object \n\n        # Create student instance, adding some courses\n        student1 = Student('Katherine', ['DS 5100'])\n        student1.enroll_in_course(\"CS 5050\")\n        student1.enroll_in_course(\"CS 5777\")\n        print(student1.courses)\n        print(student1.num_courses)\n        \n        # Test\n        expected = 3\n        # unittest.TestCase brings in the assertEqual() method\n        self.assertEqual(student1.num_courses, expected)\n        \nif __name__ == '__main__':\n    unittest.main(verbosity=2)\n```\n\nThe messages that `unittest` prints are error messages on Unix, so if we want to direct them to a file, we need to use `2>`. \n\nNotice how this command only shows the print messages contained in the program.\n\nThis one, on the other hand, captures the print methods and only shows the errors.\n\n## Further Reading\n\n* [**unittest** — Unit testing framework (Official Docs)](https://python.readthedocs.io/en/stable/library/unittest.html?highlight=re#module-unittest)\n* [How To Use unittest to Write a Test Case for a Function in Python (Digital Ocean)](https://www.digitalocean.com/community/tutorials/how-to-use-unittest-to-write-a-test-case-for-a-function-in-python)\n* [A Cheat-sheet of Unittest Assert Methods](https://kapeli.com/cheat_sheets/Python_unittest_Assertions.docset/Contents/Resources/Documents/index)\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"M08-02-PythonUnitTesting.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.262","bibliography":["../../refs.bib"],"_quarto-vars":{"version":2,"course_num":"DS 5100","course_title":"Programming for Data Science","academic_term":"Fall 2023","cohort_type":"Online","course_code":"DS5100-2023-08-O","course_allocation":"msds_ds5100","canvas_url":"https://canvas.its.virginia.edu/courses/75059","github_url":"https://github.com/ontoligent/DS5100-2023-08-O","website_url":"https://ontoligent.github.io/DS5100-2023-08-O","survey_form_url":"https://forms.office.com/r/YWaFPXPKz8","request_form_url":"https://forms.office.com/r/7G65N5eppk"},"theme":"cosmo","fig-cap-location":"bottom","reader-mode":false},"extensions":{"book":{"multiFile":true}}}}}